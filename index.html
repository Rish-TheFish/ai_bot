<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>🧠 DP AI Assistant</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        body {
            background: linear-gradient(135deg, #87CEEB 0%, #B0E0E6 100%);
            min-height: 100vh;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        .main-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            margin: 20px auto;
            max-width: 1200px;
            min-height: 80vh;
            display: flex;
            flex-direction: column;
            height: 90vh;
            min-height: 0;
        }
        .header {
            background: linear-gradient(135deg, #6c757d 0%, #495057 100%);
            color: white;
            padding: 20px 20px 0 20px;
            border-radius: 20px 20px 0 0;
            text-align: center;
            position: relative;
            z-index: 2;
        }
        .chat-area {
            flex: 1 1 auto;
            overflow-y: auto;
            padding: 10px;
            background: #f8f9fa;
            min-height: 0;
            /* Remove fixed height */
        }
        .message {
            margin-bottom: 5px;
            padding: 8px 14px;
            border-radius: 15px;
            max-width: 90%;
            word-wrap: break-word;
            font-size: 1.05rem;
            line-height: 1.3;
        }
        .user-message {
            background: linear-gradient(135deg, #87CEEB 0%, #B0E0E6 100%);
            color: white;
            margin-left: auto;
            font-size: 1.1rem;
            font-weight: 500;
        }
        .ai-message {
            background: #e9ecef;
            color: #333;
            border-left: 4px solid #87CEEB;
            font-size: 1.1rem;
            font-weight: 500;
        }
        .message-timestamp {
            font-size: 0.75rem;
            color: #6c757d;
            font-weight: 400;
            text-align: right;
            margin-top: 5px;
            opacity: 0.8;
        }
        .questionnaire-progress {
            background: rgba(135, 206, 235, 0.1);
            padding: 8px 12px;
            border-radius: 8px;
            border-left: 3px solid #87CEEB;
            margin-top: 8px;
        }
        .input-area {
            padding: 10px;
            background: white;
            border-radius: 0 0 20px 20px;
            flex-shrink: 0;
        }
        .btn-custom {
            background: linear-gradient(135deg, #87CEEB 0%, #B0E0E6 100%);
            border: none;
            color: white;
            border-radius: 25px;
            padding: 10px 25px;
        }
        .btn-custom:hover {
            color: white;
        }
        .form-control {
            border-radius: 25px;
            border: 2px solid #e9ecef;
            padding: 8px 16px;
        }
        .form-control:focus {
            border-color: #87CEEB;
            box-shadow: 0 0 0 0.2rem rgba(135, 206, 235, 0.25);
        }
        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 10px;
        }
        .status-connected { background: #28a745; }
        .status-disconnected { background: #dc3545; }
        .status-building { background: #ffc107; }
        .loading-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }
        .loading-content {
            background: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }
        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #87CEEB;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .file-upload-area {
            border: 2px dashed #87CEEB;
            border-radius: 15px;
            padding: 30px;
            text-align: center;
        }
        
        .editable-topics {
            transition: all 0.2s ease;
            position: relative;
        }
        
        .editable-topics:hover {
            background-color: #f8f9fa;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .editable-topics:active {
            background-color: #e9ecef;
            transform: translateY(1px);
        }
        
        .topics-container {
            padding: 4px;
            border-radius: 4px;
        }
        
        .topics-container:hover {
            background-color: #f8f9fa;
        }
        
        /* Enhanced tooltip styling */
        .editable-topics[title]:hover::after {
            content: attr(title);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: #333;
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            white-space: nowrap;
            z-index: 1000;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            pointer-events: none;
        }
        
        .editable-topics[title]:hover::before {
            content: '';
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 5px solid transparent;
            border-top-color: #333;
            z-index: 1000;
            pointer-events: none;
        }
        .file-upload-area:hover {
            border-color: #B0E0E6;
            background: #e9ecef;
        }
        .hidden { display: none !important; }
        
        /* Disabled button styling */
        .disabled-btn {
            opacity: 0.5 !important;
            cursor: not-allowed !important;
            background: #6c757d !important;
            border-color: #6c757d !important;
            color: #ffffff !important;
        }
        .disabled-btn:hover {
            opacity: 0.5 !important;
            background: #6c757d !important;
            border-color: #6c757d !important;
            color: #ffffff !important;
        }
        .disabled-btn:active {
            opacity: 0.5 !important;
            background: #6c757d !important;
            border-color: #6c757d !important;
            color: #ffffff !important;
        }
        
        /* Short and detailed answer styling */
        .short-answer {
            font-weight: 500;
            color: #333;
            line-height: 1.4;
        }
        
        .answer-toggle {
            color: #87CEEB;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 500;
            text-decoration: underline;
            margin-top: 5px;
            display: inline-block;
        }
        
        .answer-toggle:hover {
            color: #B0E0E6;
        }
        
                .detailed-answer {
            margin-top: 10px;
            padding: 12px;
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            font-size: 1em;
            color: #495057;
            line-height: 1.5;
            white-space: pre-wrap;
            word-break: break-word;
        }
        
        .detailed-toggle {
            cursor: pointer;
            color: #007bff;
            text-decoration: underline;
            font-weight: 500;
            margin-left: 10px;
            user-select: none;
            transition: color 0.2s ease;
        }
        
        .detailed-toggle:hover {
            color: #0056b3;
            text-decoration: none;
        }
        .upload-anim, .delete-anim {
            position: relative;
            width: 750px;
            height: 200px;
        }
        .upload-anim .file-icon {
            position: absolute;
            font-size: 4em;
            color: #87CEEB;
            opacity: 1;
            animation: file-to-folder-arc 1.2s cubic-bezier(.4,2,.6,1) forwards;
        }
        .upload-anim .file-icon:nth-child(1) {
            left: -100px; top: 40px;
            animation-delay: 0s;
        }
        .upload-anim .file-icon:nth-child(2) {
            left: -100px; top: 40px;
            animation-delay: 0.2s;
        }
        .upload-anim .file-icon:nth-child(3) {
            left: -100px; top: 40px;
            animation-delay: 0.4s;
        }
        .upload-anim .folder-icon {
            position: absolute;
            right: 75px; bottom: 30px;
            font-size: 5em;
            color: #fbbf24;
        }
        .delete-anim .folder-icon {
            position: absolute;
            left: 75px; bottom: 30px;
            font-size: 5em;
            color: #fbbf24;
        }
        .delete-anim .file-icon {
            position: absolute;
            font-size: 4em;
            color: #87CEEB;
            opacity: 1;
            animation: file-from-folder-to-trash-arc 1.2s cubic-bezier(.4,2,.6,1) forwards;
        }
        .delete-anim .file-icon:nth-child(1) {
            left: 200px; top: 40px;
            animation-delay: 0.3s;
        }
        .delete-anim .file-icon:nth-child(2) {
            left: 200px; top: 40px;
            animation-delay: 0.5s;
        }
        .delete-anim .file-icon:nth-child(3) {
            left: 200px; top: 40px;
            animation-delay: 0.7s;
        }
        .delete-anim .trash-icon {
            position: absolute;
            right: 75px; bottom: 30px;
            font-size: 5em;
            color: #dc3545;
            opacity: 0.8;
            animation: trash-pop 1.2s cubic-bezier(.4,2,.6,1) forwards;
        }
        @keyframes file-to-folder-arc {
            0% { transform: translate(0, 0) scale(1); opacity: 1; }
            100% { transform: translate(600px, 0) scale(0.8); opacity: 0; }
        }
        @keyframes file-from-folder-to-trash-arc {
            0% { transform: translate(0, 0) scale(1); opacity: 1; }
            100% { transform: translate(450px, 0) scale(0.8); opacity: 0; }
        }
        @keyframes trash-pop {
            0% { transform: scale(0.8); opacity: 0.5; }
            50% { transform: scale(1.2); opacity: 1; }
            100% { transform: scale(1); opacity: 0.8; }
        }
        .disabled-chat-input { background: #e9ecef !important; color: #aaa !important; cursor: not-allowed !important; }
        .disabled-btn {
            background: #e9ecef !important;
            color: #aaa !important;
            cursor: not-allowed !important;
            opacity: 0.6;
            border-color: #e9ecef !important;
        }
        .message strong, .message b {
            font-size: 1.05em;
        }
        .message .emoji, .message span[style*="font-size"] {
            font-size: 1.5em !important;
            vertical-align: middle;
        }
        .chat-area, .logsArea {
            border-top-left-radius: 0;
            border-top-right-radius: 0;
        }
        
        /* Source toggle styling */
        .source-toggle {
            cursor: pointer;
            color: #007bff;
            font-weight: bold;
            margin-left: 5px;
            user-select: none;
            transition: color 0.2s;
        }
        .source-toggle:hover {
            color: #0056b3;
        }
        .source-summary {
            font-weight: 500;
        }
        .source-detailed {
            margin-top: 8px;
            padding: 10px;
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            font-size: 0.9em;
            color: #6c757d;
            line-height: 1.4;
            white-space: pre-wrap;
            word-break: break-word;
            max-width: 100%;
            /* Removed height restriction to show full AI responses */
            overflow: visible;
        }
        
        /* IDK Highlighting Styles */
        .idk-highlight {
            font-size: 1.3rem !important;
            font-weight: bold !important;
            color: #d32f2f !important;
            background-color: rgba(211, 47, 47, 0.1);
            padding: 2px 6px;
            border-radius: 4px;
            border: 2px solid #d32f2f;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.1);
        }
        
        /* IDK Alert Modal */
        .idk-alert-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #fff;
            border: 3px solid #d32f2f;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            z-index: 9999;
            max-width: 400px;
            text-align: center;
            animation: idkAlertPulse 0.5s ease-in-out;
        }
        
        .idk-alert-modal h3 {
            color: #d32f2f;
            margin-bottom: 15px;
            font-size: 1.4rem;
        }
        
        .idk-alert-modal p {
            color: #333;
            margin-bottom: 20px;
            font-size: 1.1rem;
        }
        
        /* .idk-alert-modal button styling removed - now using specific button classes */
        
        .idk-alert-modal button:hover {
            background: #b71c1c;
        }
        
        .idk-alert-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
        }
        
        .idk-alert-modal .btn-details {
            background: #2196f3;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 25px;
            font-size: 1rem;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        .idk-alert-modal .btn-details:hover {
            background: #1976d2;
        }
        
        .idk-alert-modal .btn-acknowledge {
            background: #d32f2f;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 25px;
            font-size: 1rem;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        .idk-alert-modal .btn-acknowledge:hover {
            background: #b71c1c;
        }
        
        /* IDK Details Modal */
        .idk-details-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .idk-details-content {
            background: #fff;
            border-radius: 15px;
            padding: 25px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }
        
        .idk-details-content h4 {
            color: #2196f3;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .question-text {
            background: #f5f5f5;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            font-size: 1.1rem;
            line-height: 1.5;
            word-wrap: break-word;
        }
        
        .idk-details-content .btn-close {
            background: #666;
            color: white;
            border: none;
            padding: 10px 25px;
            border-radius: 25px;
            font-size: 1rem;
            cursor: pointer;
            transition: background 0.3s;
            margin-top: 15px;
            width: 100%;
        }
        
        .idk-details-content .btn-close:hover {
            background: #555;
        }
        
        /* Questions List Styling */
        .questions-list {
            max-height: 400px;
            overflow-y: auto;
            margin: 20px 0;
        }
        
        .question-item {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
        }
        
        .question-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .question-number {
            background: #007bff;
            color: white;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.9rem;
            font-weight: bold;
        }
        
        .question-time {
            color: #6c757d;
            font-size: 0.85rem;
        }
        
        .question-text {
            background: #e9ecef;
            border: 1px solid #ced4da;
            border-radius: 6px;
            padding: 12px;
            margin: 10px 0;
            font-size: 1rem;
            line-height: 1.4;
            word-wrap: break-word;
        }
        
        .ai-response {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 6px;
            padding: 10px;
            margin-top: 10px;
            font-size: 0.9rem;
            color: #856404;
            font-style: italic;
        }
        
        .modal-actions {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        
        .btn-clear {
            background: #dc3545;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 25px;
            font-size: 1rem;
            cursor: pointer;
            transition: background 0.3s;
            flex: 1;
        }
        
        .btn-clear:hover {
            background: #c82333;
        }
        
        .btn-close {
            background: #666;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 25px;
            font-size: 1rem;
            cursor: pointer;
            transition: background 0.3s;
            flex: 1;
        }
        
        @keyframes idkAlertPulse {
            0% { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
            50% { transform: translate(-50%, -50%) scale(1.05); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }
        
        .idk-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 9998;
        }
    </style>
</head>
<body>
    <div class="container-fluid">
        <div class="main-container">
            <div class="header" style="position: relative; padding-bottom: 0;">
                <div class="d-flex align-items-center justify-content-between mb-2">
                    <div class="d-flex flex-column align-items-start" style="min-width:180px;">
                        <!-- Empty space for balance -->
                    </div>
                    <h2 class="flex-grow-1 mb-0 text-center" style="color:white;"><i class="fas fa-brain"></i> DP AI Assistant</h2>
                    <div class="text-end" style="min-width:220px;">
                        <div class="mb-1">
                            <span class="status-indicator status-disconnected" id="statusIndicator"></span>
                            <span id="statusText" style="font-size: 0.9em; font-weight: 500;">Disconnected</span>
                        </div>
                    </div>
                </div>
                <div class="d-flex align-items-end justify-content-between" style="height: 40px;">
                    <div class="btn-group" role="group" style="margin-left: 0;">
                        <button type="button" class="btn btn-toggle-chat active" id="chatTabBtn">
                            
                            <i class="fas fa-comments"></i> Chat
                        </button>
                        <button type="button" class="btn btn-toggle-chat" id="logsTabBtn">
                            <i class="fas fa-list"></i> Alerts
                        </button>
                        <button type="button" class="btn btn-toggle-chat" id="docsTabBtn">
                            <i class="fas fa-folder-open"></i> Docs
                        </button>
                    </div>
                    <div class="d-flex align-items-center justify-content-center flex-grow-1">
                        <div class="dropdown" style="position: relative; margin-left: -215px;">
                            <button class="btn btn-outline-light dropdown-toggle" type="button" id="chatTopicsDropdownBtn" data-bs-toggle="dropdown" aria-expanded="false" style="font-size: 1.1em; padding: 8px 20px; height: 32px; line-height: 1; min-width: 160px;">
                                <i class="fas fa-tags me-2"></i> All Topics
                            </button>
                            <ul class="dropdown-menu" id="chatTopicsDropdownMenu" style="max-height: 300px; overflow-y: auto; min-width: 280px; position: absolute; left: 0; right: auto;"></ul>
                        </div>
                    </div>
                    <div class="d-flex align-items-center" style="min-width: 120px;">
                        <span id="userStatusText2" style="font-size: 1em; font-weight: 500; color: white;">Shared User</span>
                        <!-- Login/Register buttons removed - no longer needed with shared user system -->
                    </div>
                </div>
            </div>
            <style>
            .header {
                background: linear-gradient(135deg, #6c757d 0%, #495057 100%);
                color: white;
                padding: 20px 20px 0 20px;
                border-radius: 20px 20px 0 0;
                text-align: center;
                position: relative;
                z-index: 2;
            }
            .btn-toggle-chat {
                background: transparent;
                color: white;
                border: none;
                border-radius: 12px 12px 0 0;
                margin-right: 4px;
                padding: 8px 24px 8px 20px;
                font-weight: 500;
                box-shadow: none;
                transition: background 0.2s, color 0.2s, box-shadow 0.2s;
            }
            .btn-toggle-chat.active, .btn-toggle-chat:focus {
                background: #fff;
                color: #B0E0E6;
                box-shadow: 0 4px 12px rgba(135,206,235,0.10);
                z-index: 2;
                position: relative;
            }
            .btn-toggle-chat:not(.active):hover {
                background: rgba(255,255,255,0.15);
                color: #fff;
            }
            .chat-area, .logsArea {
                border-top-left-radius: 0;
                border-top-right-radius: 0;
            }
            
            /* Header topic selector styling */
            .header .dropdown .btn-outline-light {
                border-color: rgba(255, 255, 255, 0.3);
                color: white;
                background: transparent;
                transition: all 0.2s ease;
                font-weight: 500;
            }
            
            .header .dropdown .btn-outline-light:hover {
                border-color: rgba(255, 255, 255, 0.6);
                background: rgba(255, 255, 255, 0.1);
                color: white;
            }
            
            .header .dropdown .btn-outline-light:focus,
            .header .dropdown .btn-outline-light.show {
                border-color: rgba(255, 255, 255, 0.8);
                background: rgba(255, 255, 255, 0.15);
                color: white;
                box-shadow: 0 0 0 0.2rem rgba(255, 255, 255, 0.25);
            }
            
            .header .dropdown-menu {
                border: none;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
                border-radius: 8px;
                z-index: 1000;
                margin-top: 5px;
                overflow: visible;
                min-width: 280px !important;
            }
            
            /* Ensure dropdown positioning works correctly in header */
            .header .dropdown {
                position: relative;
            }
            
            .header .dropdown-menu.show {
                display: block;
                transform: none !important;
            }
            
            /* Center the topic selector properly */
            .header .d-flex.justify-content-center {
                position: relative;
                overflow: visible;
            }
            
            /* Ensure dropdown container doesn't clip content */
            .header .dropdown {
                overflow: visible;
            }
            
            /* Prevent any clipping of dropdown content */
            .header {
                overflow: visible;
            }
            
            .main-container {
                overflow: visible;
            }
            
            .container-fluid {
                overflow: visible;
            }
            
            .header .dropdown-menu {
                text-align: left;
                min-width: 220px !important;
                max-width: 280px;
            }
            
            /* Style the dropdown menu items */
            .header .dropdown-menu .form-check {
                text-align: left;
                padding: 8px 20px 8px 30px;
                margin: 0;
                border-bottom: 1px solid #f8f9fa;
                white-space: nowrap;
                min-width: 280px;
            }
            
            .header .dropdown-menu .form-check:last-child {
                border-bottom: none;
            }
            
            .header .dropdown-menu .form-check-input {
                margin-right: 8px;
                flex-shrink: 0;
            }
            
            .header .dropdown-menu .form-check-label {
                cursor: pointer;
                user-select: none;
                font-size: 0.95em;
                flex-grow: 1;
                overflow: hidden;
                text-overflow: ellipsis;
            }
            
            /* Responsive adjustments for smaller screens */
            @media (max-width: 768px) {
                .header .dropdown .btn {
                    font-size: 1em !important;
                    padding: 6px 16px !important;
                    min-width: 140px !important;
                }
                
                .header .dropdown-menu {
                    min-width: 200px;
                }
                
                .header .d-flex.justify-content-center {
                    order: 2;
                }
                
                .header .btn-group {
                    order: 1;
                }
                
                .header .d-flex.align-items-center:last-child {
                    order: 3;
                }
            }
            
            /* Clear History Modal Styling */
            #clearHistoryModal .modal-body {
                max-height: 70vh;
                overflow-y: auto;
            }
            
            #clearHistoryModal .form-check {
                margin-bottom: 8px;
                padding: 8px 12px;
                border-radius: 6px;
                transition: background-color 0.2s;
            }
            
            #clearHistoryModal .form-check:hover {
                background-color: #f8f9fa;
            }
            
            #clearHistoryModal .form-check-input:checked + .form-check-label {
                font-weight: 600;
                color: #dc3545;
            }
            
            #clearHistoryModal .btn-outline-secondary {
                border-color: #6c757d;
                color: #6c757d;
            }
            
            #clearHistoryModal .btn-outline-secondary:hover {
                background-color: #6c757d;
                border-color: #6c757d;
                color: white;
            }
            
            #clearHistoryModal .badge {
                font-size: 0.75em;
                padding: 2px 6px;
            }
            
            #clearHistoryModal .form-check-label {
                display: flex;
                align-items: center;
                justify-content: space-between;
                width: 100%;
            }
            </style>
            <!-- Welcome message above status, left-aligned -->
            <div class="chat-area" id="chatMessages">
                <div class="message ai-message">
                    <strong>🤖 AI Assistant:</strong> Welcome! I'm your DP AI Assistant. Please upload compliance documents or ask a question to get started.
                </div>
            </div>
            <div class="chat-area hidden" id="logsArea" style="height: calc(100vh - 200px); overflow-y: auto; position: relative;">
                <div style="position: fixed; top: 10px; right: 10px; z-index: 1000; display: flex; gap: 5px;">
                    <button class="btn btn-outline-info btn-sm" id="testEmbeddingsBtn" style="background: white; border: 1px solid #17a2b8; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                        <i class="fas fa-brain"></i> Test Embeddings
                    </button>
                    <button class="btn btn-outline-warning btn-sm" id="forceRebuildBtn" style="background: white; border: 1px solid #ffc107; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                        <i class="fas fa-sync-alt"></i> Force Rebuild
                    </button>
                    <button class="btn btn-outline-secondary btn-sm" id="clearLogsBtn" style="background: white; border: 1px solid #ccc; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                        <i class="fas fa-trash"></i> Clear
                    </button>
                </div>
                <div id="logsContent" style="padding-top: 50px;">
                <div class="message ai-message">
                    <strong>📋 System Logs:</strong> System activity and mode changes will appear here.
                    </div>
                </div>
            </div>
            <!-- Independent Document Management Area -->
            <div class="docs-area hidden" id="docsArea" style="height: calc(100vh - 200px); overflow-y: auto; padding: 20px; background: #f8f9fa;">
                <div class="message ai-message" style="background: transparent; color: #B0E0E6; border-left: none; margin-bottom: 0;">
                    <strong>Welcome to the Document Manager.</strong>
                </div>
                <div class="d-flex justify-content-between align-items-center" style="margin-bottom: 20px;">
                    <div class="d-flex align-items-center gap-3">
                        <h5 class="mb-0"><i class="fas fa-folder-open"></i> Document Management</h5>
                        <div class="dropdown">
                            <button class="btn btn-outline-primary dropdown-toggle" type="button" id="topicDropdown" data-bs-toggle="dropdown" aria-expanded="false">
                                <i class="fas fa-tags"></i> <span id="currentTopicName">All Topics</span>
                            </button>
                            <ul class="dropdown-menu" id="topicDropdownMenu" style="min-width: 250px;">
                                <li><a class="dropdown-item" href="#" data-topic="all">📁 All Topics</a></li>
                                <li><hr class="dropdown-divider"></li>
                                <li><a class="dropdown-item" href="#" id="createTopicBtn"><i class="fas fa-plus"></i> Create New Topic</a></li>
                                <li><hr class="dropdown-divider"></li>
                                <li><div class="dropdown-item-text"><strong>Select Topics:</strong></div></li>
                                <li><div id="topicCheckboxes" class="px-3 py-2"></div></li>
                                <li><hr class="dropdown-divider"></li>
                                <li><button class="dropdown-item text-danger" href="#" id="deleteTopicsBtn" disabled><i class="fas fa-trash"></i> Delete Selected Topics</button></li>
                            </ul>
                        </div>
                    </div>
                    <div class="d-flex gap-2">
                        <button class="btn btn-secondary" id="addDocBtn" style="width: 120px;"><i class="fas fa-plus"></i> Add Documents</button>
                        <button class="btn btn-danger" id="bulkDeleteBtn" style="width: 120px;" disabled><i class="fas fa-trash"></i> Delete Selected</button>
                        <button class="btn btn-warning" id="bulkReplaceBtn" style="width: 120px;" disabled><i class="fas fa-sync-alt"></i> Replace Selected</button>
                        <input type="file" id="addDocInput" class="d-none" multiple accept=".pdf,.docx,.txt,.csv,.xml">
                        <input type="file" id="bulkReplaceInput" class="d-none" accept=".pdf,.docx,.txt,.csv,.xml">
                    </div>
                </div>
                <table class="table table-striped table-hover bg-white rounded shadow-sm">
                    <thead class="table-light">
                        <tr>
                            <th style="width: 50px;"><input type="checkbox" id="selectAllCheckbox" class="form-check-input"></th>
                            <th>Name <span class="sort-arrow" data-col="name" style="cursor:pointer;">▼</span></th>
                            <th>Topics <span class="sort-arrow" data-col="topics" style="cursor:pointer;">▼</span></th>
                            <th>Type <span class="sort-arrow" data-col="type" style="cursor:pointer;">▼</span></th>
                            <th>Uploaded <span class="sort-arrow" data-col="uploaded" style="cursor:pointer;">▼</span></th>
                            <th style="width: 120px;">Rename</th>
                        </tr>
                    </thead>
                    <tbody id="docsTableBody">
                        <!-- Document rows will be inserted here -->
                        <tr><td colspan="6" class="text-center text-muted">No documents uploaded yet.</td></tr>
                    </tbody>
                </table>
            </div>
            <!-- Replace Document Modal -->
            <div class="modal fade" id="replaceDocModal" tabindex="-1">
                <div class="modal-dialog">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title">Replace Document</h5>
                            <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                        </div>
                        <div class="modal-body">
                            <input type="file" id="replaceDocInput" accept=".pdf,.docx,.txt,.csv,.xml">
                            <input type="hidden" id="replaceDocName">
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                            <button type="button" class="btn btn-primary" id="confirmReplaceBtn">Replace</button>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Filename Conflict Modal -->
            <div class="modal fade" id="filenameConflictModal" tabindex="-1">
                <div class="modal-dialog">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title">Filename Conflict</h5>
                            <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                        </div>
                        <div class="modal-body">
                            <p id="conflictMessage">A file with this name already exists.</p>
                            <div class="mb-3">
                                <label for="newFilename" class="form-label">New Filename:</label>
                                <input type="text" class="form-control" id="newFilename" placeholder="Enter new filename">
                                <div class="form-text">Enter a new name for the file</div>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-secondary" id="cancelConflictBtn">Cancel</button>
                            <button type="button" class="btn btn-primary" id="renameConflictBtn">Rename & Continue</button>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Rename Document Modal -->
            <div class="modal fade" id="renameDocModal" tabindex="-1">
                <div class="modal-dialog">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title">Rename Document</h5>
                            <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                        </div>
                        <div class="modal-body">
                            <div class="mb-3">
                                <label for="renameOldFilename" class="form-label">Current Name:</label>
                                <input type="text" class="form-control" id="renameOldFilename" readonly style="background-color: #f8f9fa; color: #6c757d; cursor: not-allowed;">
                            </div>
                            <div class="mb-3">
                                <label for="renameNewFilename" class="form-label">New Name:</label>
                                <input type="text" class="form-control" id="renameNewFilename" placeholder="Enter new filename">
                                <div class="form-text">Enter a new name for the file</div>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                            <button type="button" class="btn btn-primary" id="confirmRenameBtn">Rename</button>
                        </div>
                    </div>
                </div>
            </div>
            
                         <!-- Create Topic Modal -->
             <div class="modal fade" id="createTopicModal" tabindex="-1">
                 <div class="modal-dialog">
                     <div class="modal-content">
                         <div class="modal-header">
                             <h5 class="modal-title">Create New Topic</h5>
                             <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                         </div>
                         <div class="modal-body">
                             <div class="mb-3">
                                 <label for="topicName" class="form-label">Topic Name:</label>
                                 <input type="text" class="form-control" id="topicName" placeholder="e.g., Compliance, Manual Guides, Policies">
                                 <div class="form-text">Enter a descriptive name for your topic</div>
                             </div>
                             <div class="mb-3">
                                 <label for="topicDescription" class="form-label">Description (Optional):</label>
                                 <textarea class="form-control" id="topicDescription" rows="3" placeholder="Brief description of what this topic contains..."></textarea>
                             </div>
                         </div>
                         <div class="modal-footer">
                             <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                             <button type="button" class="btn btn-primary" id="confirmCreateTopicBtn">Create Topic</button>
                         </div>
                     </div>
                 </div>
             </div>
             
             <!-- Delete Topics Confirmation Modal -->
             <div class="modal fade" id="deleteTopicsModal" tabindex="-1">
                 <div class="modal-dialog">
                     <div class="modal-content">
                         <div class="modal-header">
                             <h5 class="modal-title text-danger"><i class="fas fa-exclamation-triangle"></i> Delete Topics</h5>
                             <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                         </div>
                         <div class="modal-body">
                             <p class="text-danger"><strong>Warning:</strong> This action cannot be undone.</p>
                             <p>Are you sure you want to delete the following topic(s)?</p>
                             <ul id="topicsToDeleteList" class="list-group mb-3">
                                 <!-- Topics will be listed here -->
                             </ul>
                             <div class="alert alert-warning">
                                 <i class="fas fa-info-circle"></i>
                                 <strong>Note:</strong> This will remove these tags from all documents, but the documents will remain in "All Topics".
                             </div>
                         </div>
                         <div class="modal-footer">
                             <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                             <button type="button" class="btn btn-danger" id="confirmDeleteTopicsBtn">
                                 <i class="fas fa-trash"></i> Delete Topics
                             </button>
                         </div>
                     </div>
                 </div>
             </div>
             
             <!-- Bulk Delete Documents Confirmation Modal -->
             <div class="modal fade" id="bulkDeleteModal" tabindex="-1">
                 <div class="modal-dialog">
                     <div class="modal-content">
                         <div class="modal-header">
                             <h5 class="modal-title text-danger"><i class="fas fa-exclamation-triangle"></i> Delete Documents</h5>
                             <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                         </div>
                         <div class="modal-body">
                             <p class="text-danger"><strong>Warning:</strong> This action cannot be undone.</p>
                             <p>Are you sure you want to delete the following document(s)?</p>
                             <ul id="documentsToDeleteList" class="list-group mb-3">
                                 <!-- Documents will be listed here -->
                             </ul>
                         </div>
                         <div class="modal-footer">
                             <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                             <button type="button" class="btn btn-danger" id="confirmBulkDeleteBtn">
                                 <i class="fas fa-trash"></i> Delete Documents
                             </button>
                         </div>
                     </div>
                 </div>
             </div>
             
             <!-- Bulk Replace Documents Confirmation Modal -->
             <div class="modal fade" id="bulkReplaceModal" tabindex="-1">
                 <div class="modal-dialog">
                     <div class="modal-content">
                         <div class="modal-header">
                             <h5 class="modal-title text-warning"><i class="fas fa-sync-alt"></i> Replace Documents</h5>
                             <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                         </div>
                         <div class="modal-body">
                             <p class="text-warning"><strong>Warning:</strong> This will replace the selected documents with new files.</p>
                             <p>Are you sure you want to replace the following document(s)?</p>
                             <ul id="documentsToReplaceList" class="list-group mb-3">
                                 <!-- Documents will be listed here -->
                             </ul>
                             <div class="alert alert-info">
                                 <i class="fas fa-info-circle"></i>
                                 <strong>Note:</strong> Please select exactly the same number of files to replace the selected documents.
                             </div>
                         </div>
                         <div class="modal-footer">
                             <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                             <button type="button" class="btn btn-warning" id="confirmBulkReplaceBtn">
                                 <i class="fas fa-sync-alt"></i> Replace Documents
                             </button>
                         </div>
                     </div>
                 </div>
             </div>
             
             <!-- Edit Document Topics Modal -->
             <div class="modal fade" id="editTopicsModal" tabindex="-1">
                 <div class="modal-dialog">
                     <div class="modal-content">
                         <div class="modal-header">
                             <h5 class="modal-title"><i class="fas fa-tags"></i> Edit Document Topics</h5>
                             <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                         </div>
                         <div class="modal-body">
                             <p><strong>Document:</strong> <span id="editTopicsDocName"></span></p>
                             <p class="text-muted">Select the topics this document should be associated with:</p>
                             <div id="editTopicsCheckboxes" class="mb-3">
                                 <!-- Topic checkboxes will be populated here -->
                             </div>
                         </div>
                         <div class="modal-footer">
                             <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                             <button type="button" class="btn btn-primary" id="saveTopicsBtn">Save Changes</button>
                         </div>
                     </div>
                 </div>
             </div>
             
             <!-- Clear History Modal -->
             <div class="modal fade" id="clearHistoryModal" tabindex="-1">
                 <div class="modal-dialog modal-lg">
                     <div class="modal-content">
                         <div class="modal-header">
                             <h5 class="modal-title text-danger"><i class="fas fa-trash"></i> Clear Chat History</h5>
                             <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                         </div>
                         <div class="modal-body">
                             <div class="alert alert-warning">
                                 <i class="fas fa-exclamation-triangle"></i>
                                 <strong>Warning:</strong> This action cannot be undone. Selected chat histories will be permanently deleted.
                             </div>
                             <div class="alert alert-info">
                                 <i class="fas fa-info-circle"></i>
                                 <strong>Note:</strong> This will clear chat history for the selected topic combinations. Individual topics and their combinations are stored separately in the database.
                             </div>
                             <p class="mb-3">Select which topic combinations to clear:</p>
                             <div class="row">
                                 <div class="col-md-6">
                                     <h6>Individual Topics:</h6>
                                     <div id="individualTopicsCheckboxes" class="mb-3">
                                         <!-- Individual topic checkboxes will be populated here -->
                                     </div>
                                 </div>
                                 <div class="col-md-6">
                                     <h6>Topic Combinations:</h6>
                                     <div id="combinationTopicsCheckboxes" class="mb-3">
                                         <!-- Topic combination checkboxes will be populated here -->
                                     </div>
                                 </div>
                             </div>
                             <div class="mt-3">
                                 <button type="button" class="btn btn-outline-secondary btn-sm" id="selectAllTopicsBtn">
                                     <i class="fas fa-check-square"></i> Select All
                                 </button>
                                 <button type="button" class="btn btn-outline-secondary btn-sm ms-2" id="deselectAllTopicsBtn">
                                     <i class="fas fa-square"></i> Deselect All
                                 </button>
                             </div>
                         </div>
                         <div class="modal-footer">
                             <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                             <button type="button" class="btn btn-danger" id="confirmClearHistoryBtn" disabled>
                                 <i class="fas fa-trash"></i> Clear Selected Histories
                             </button>
                         </div>
                     </div>
                 </div>
             </div>
            <div class="input-area">
                <div class="row mb-2 justify-content-center">
                    <div class="col-md-8 d-flex">
                        <input type="text" class="form-control flex-grow-1" id="questionInput" placeholder="Ask your compliance question..." disabled>
                        <button class="btn btn-custom ms-2" id="askButton" disabled>
                            <i class="fas fa-paper-plane"></i>
                        </button>
                    </div>
                </div>
                <div class="row justify-content-center mb-1">
                    <div class="col-md-2 d-flex justify-content-center">
                        <button class="btn btn-outline-secondary w-100" id="exportBtn">
                            <i class="fas fa-download"></i> Export Chat
                        </button>
                    </div>
                    <!-- <div class="col-md-2 d-flex justify-content-center">
                        <button class="btn btn-outline-warning w-100" id="checkDocsBtn" disabled>
                            <i class="fas fa-search"></i> Check Documents
                        </button>
                    </div> -->
                    <div class="col-md-2 d-flex justify-content-center">
                        <button class="btn btn-outline-info w-100" id="batchQnAButton" disabled>
                    <i class="fas fa-question-circle"></i> Upload Questionnaire
</button>
                    </div>
                    <div class="col-md-2 d-flex justify-content-center">
                        <button class="btn btn-outline-danger w-100" id="clearHistoryBtn">
                            <i class="fas fa-trash"></i> Clear History
                        </button>
                    </div>
                    <div class="col-md-2 d-flex justify-content-center">
                        <button class="btn btn-outline-info w-100" id="checkIntegrityBtn">
                            <i class="fas fa-shield-alt"></i> Check Integrity
                        </button>
                    </div>
                </div>
                <!-- Remove uploadPanel div if not used elsewhere -->
                <!-- Batch Q&A Upload Panel -->
<div id="batchQnAPanel" class="hidden mt-3 p-3 border rounded">
    <h5><i class="fas fa-question-circle"></i> Upload Questionnaire</h5>
                    <div class="file-upload-area" onclick="document.getElementById('batchQnAInput').click()">
                        <i class="fas fa-cloud-upload-alt fa-3x text-primary mb-3"></i>
                        <h5>Click to select a file of questions</h5>
                        <p class="text-muted">Supported formats: PDF, DOCX, TXT, CSV, XML</p>
                        <input type="file" id="batchQnAInput" accept=".pdf,.docx,.txt,.csv,.xml" style="display: none;">
                    </div>
                    <div id="batchQnAFileName" class="mt-2"></div>
                    <button class="btn btn-primary mt-2" id="batchQnAUploadBtn" disabled>Upload & Get Answers</button>
                    <button class="btn btn-secondary mt-2 ms-2" id="cancelBatchQnABtn">Cancel</button>
                    

                </div>
                <!-- Loading Spinner -->
                <div id="batchQnALoading" class="loading-overlay" style="display:none;">
                    <div class="loading-content">
                        <div class="spinner"></div>
                        <div>🤖 AI is thinking...</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Login Modal removed - no longer needed with shared user system -->
    
    <!-- Register Modal removed - no longer needed with shared user system -->
    
    <!-- Upload Animation -->
    <!-- <div id="uploadAnimation" style="display:none; position:fixed; left:50%; top:50%; transform:translate(-50%, -50%); z-index:2000; pointer-events:none;">
      <div class="upload-anim">
        <span class="file-icon">📄</span>
        <span class="file-icon">📋</span>
        <span class="file-icon">📝</span>
        <span class="folder-icon">📁</span>
      </div>
    </div> -->
    <!-- Delete Animation -->
    <!-- <div id="deleteAnimation" style="display:none; position:fixed; left:50%; top:50%; transform:translate(-50%, -50%); z-index:2000; pointer-events:none;">
      <div class="delete-anim">
        <span class="folder-icon">📁</span>
        <span class="file-icon">📄</span>
        <span class="file-icon">📋</span>
        <span class="file-icon">📝</span>
        <span class="trash-icon">🗑️</span>
      </div>
    </div> -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script>
let aiInitialized = false;
        const UPLOAD_PIN = "1964"; // PIN from config_details.py
        let uploadPinCache = null;
        let uploadButtonUnlocked = false; // Track if upload button is unlocked
        let wrongPinAttempts = 0; // Track wrong PIN attempts
        const MAX_PIN_ATTEMPTS = 3; // Maximum allowed wrong attempts
let pendingAnimationStop = null;

window.addEventListener('DOMContentLoaded', function() {
    updateStatus('building'); // Show building status immediately
    initializeAI();
    setupEventListeners();
    // Add event delegation for sort-arrow clicks
    const docsTableThead = document.querySelector('.table thead');
    if (docsTableThead) {
        docsTableThead.addEventListener('click', function(e) {
            const arrow = e.target.closest('.sort-arrow');
            if (!arrow) return;
            const col = arrow.getAttribute('data-col');
            if (!col) return;
            // If the click is on the superscript (number), show popup
            if (e.target.tagName === 'SUP') {
                const idx = sortLevels.findIndex(s => s.column === col);
                showSortOrderPopup(arrow, col, idx);
                return;
            }
            // Otherwise, make this the main sorter
            const idx = sortLevels.findIndex(s => s.column === col);
            if (idx === -1) {
                sortLevels.unshift({ column: col, direction: 'desc' });
            } else if (idx === 0) {
                // Cycle direction or remove
                if (sortLevels[0].direction === 'desc') {
                    sortLevels[0].direction = 'asc';
                } else if (sortLevels[0].direction === 'asc') {
                    // Third press: remove from sortLevels
                    sortLevels.splice(0, 1);
                    if (sortLevels.length === 0) {
                        sortLevels = [{ column: 'topics', direction: 'asc' }];
                    }
                }
            } else {
                // Move to main sorter, keep direction
                const [item] = sortLevels.splice(idx, 1);
                sortLevels.unshift(item);
            }
            renderDocsTable();
            updateSortArrows();
        });
    }
    // Populate chat topics dropdown (Bootstrap style)
    fetch('/get_topics')
        .then(res => res.json())
        .then(data => {
            const menu = document.getElementById('chatTopicsDropdownMenu');
            const btn = document.getElementById('chatTopicsDropdownBtn');
            if (!menu || !btn) return;
            menu.innerHTML = '';
                    // All Topics is now the default
            // All Topics option (checkbox)
            const allLi = document.createElement('li');
            allLi.innerHTML = `<div class="form-check"><input class="form-check-input" type="checkbox" value="all" id="chatTopic_all"><label class="form-check-label" for="chatTopic_all">All Topics</label></div>`;
            menu.appendChild(allLi);
            // Other topics (checkboxes)
            (data.topics || []).forEach(topic => {
                const li = document.createElement('li');
                li.innerHTML = `<div class="form-check"><input class="form-check-input" type="checkbox" value="${topic.id}" id="chatTopic_${topic.id}"><label class="form-check-label" for="chatTopic_${topic.id}">${topic.name}</label></div>`;
                menu.appendChild(li);
            });
            // Selection logic
            function updateBtnLabel() {
                const checked = menu.querySelectorAll('.form-check-input:checked');
                if (checked.length === 0 || (checked.length === 1 && checked[0].value === 'all')) {
                    btn.textContent = 'All Topics';
                } else {
                    const names = Array.from(checked).filter(cb => cb.value !== 'all').map(cb => menu.querySelector(`label[for="chatTopic_${cb.value}"]`).textContent);
                    btn.textContent = names.length > 0 ? names.join(', ') : 'All Topics';
                }
            }
            
            // Make updateBtnLabel globally accessible
            window.updateBtnLabel = updateBtnLabel;
            // Note: Event handling is now done in attachChatTopicsDropdownHandler()
            // This prevents duplicate event handlers and ensures proper chat history management
            
            // Set initial state: All Topics checked (default) and ensure it's the only selection
            // This ensures that every time the page loads, "All Topics" is the default selection
            const allCheckbox = menu.querySelector('.form-check-input[value="all"]');
            if (allCheckbox) {
                allCheckbox.checked = true;
                // Uncheck all other topics to ensure only All Topics is selected
                const otherCheckboxes = menu.querySelectorAll('.form-check-input:not([value="all"])');
                otherCheckboxes.forEach(cb => cb.checked = false);
            }
            
            updateBtnLabel();
            // Update the Upload Questionnaire button initially
            updateUploadQuestionnaireButton();
            attachChatTopicsDropdownHandler && attachChatTopicsDropdownHandler();
        });
    // On DOMContentLoaded, also enforce chat bar state and ensure All Topics is default
    document.addEventListener('DOMContentLoaded', function() {
        // Ensure All Topics is always selected by default on page load
        setTimeout(() => {
            const menu = document.getElementById('chatTopicsDropdownMenu');
            if (menu) {
                const allCheckbox = menu.querySelector('.form-check-input[value="all"]');
                if (allCheckbox) {
                    allCheckbox.checked = true;
                    // Uncheck all other topics
                    const otherCheckboxes = menu.querySelectorAll('.form-check-input:not([value="all"])');
                    otherCheckboxes.forEach(cb => cb.checked = false);
                }
            }
            
            // Update selected topics to reflect All Topics selection
            window.selectedTopics = new Set(['all']);
            currentChatSessionKey = 'topics:all';
            
            // Update button label and chat input state
            if (window.updateBtnLabel) updateBtnLabel();
            updateChatInputState();
            
            // Also update the Upload Questionnaire button state
            if (window.updateUploadQuestionnaireButton) updateUploadQuestionnaireButton();
            
            // Ensure the button text shows "All Topics"
            const btn = document.getElementById('chatTopicsDropdownBtn');
            if (btn) btn.textContent = 'All Topics';
            
            // Add a log message to show that All Topics is the default
            addLogMessage('✅ All Topics selected by default - Chat is now enabled');
            
            // Load initial chat history for All Topics session
            fetchChatHistory(currentChatSessionKey);
        }, 100);
    });
    // --- Per-topic-selection chat session logic ---
    function getChatSessionKey(selectedTopics) {
        if (!selectedTopics || selectedTopics.length === 0 || selectedTopics.includes('all')) {
            return 'topics:all';
        }
        // Always sort for consistency
        const sorted = [...selectedTopics].sort();
        return 'topics:' + sorted.join(',');
    }

    let currentChatSessionKey = 'topics:all';
    let chatHistories = {}; // sessionKey -> array of {question, answer}

    function displayChatHistory(sessionKey) {
        console.log(`[DEBUG] Displaying chat history for session: ${sessionKey}`);
        console.log(`[DEBUG] Available chat histories:`, Object.keys(chatHistories));
        console.log(`[DEBUG] History for this session:`, chatHistories[sessionKey]);
        
        const chatMessages = document.getElementById('chatMessages');
        chatMessages.innerHTML = '';
        
        // Show the initial AI welcome message with topic name(s)
        const menu = document.getElementById('chatTopicsDropdownMenu');
        let topicLabel = 'All Topics';
        let isAllTopics = true;
        if (menu) {
            const checked = menu.querySelectorAll('.form-check-input:checked');
            if (checked.length === 0 || checked[0].value === 'all') {
                topicLabel = 'All Topics';
                isAllTopics = true;
            } else {
                const names = Array.from(checked).map(c => menu.querySelector(`label[for="chatTopic_${c.value}"]`).textContent);
                topicLabel = names.join(', ');
                isAllTopics = false;
            }
        }
        
        // Welcome message - All Topics is now the default
        addMessage(`🤖 AI Assistant: Welcome! I'm your DP AI Assistant. <br><b>Current Topic(s):</b> ${topicLabel}<br>Please upload compliance documents or ask a question to get started.`, 'ai', false);
        
        // Check if we have history for this session
        const history = chatHistories[sessionKey] || [];
        console.log(`[DEBUG] History length: ${history.length}`);
        
        if (history.length === 0) {
            console.log(`[DEBUG] No history found for session ${sessionKey}, fetching from server...`);
            // If no history in memory, fetch it from the server
            fetchChatHistory(sessionKey);
            return; // Don't display anything yet, wait for fetch to complete
        }
        
        // Display the history
        displayChatHistoryDirectly(sessionKey);
    }

    function displayChatHistoryDirectly(sessionKey) {
        console.log(`[DEBUG] Displaying chat history directly for session: ${sessionKey}`);
        
        const chatMessages = document.getElementById('chatMessages');
        chatMessages.innerHTML = '';
        
        // Show the initial AI welcome message with topic name(s)
        const menu = document.getElementById('chatTopicsDropdownMenu');
        let topicLabel = 'All Topics';
        let isAllTopics = true;
        if (menu) {
            const checked = menu.querySelectorAll('.form-check-input:checked');
            if (checked.length === 0 || checked[0].value === 'all') {
                topicLabel = 'All Topics';
                isAllTopics = true;
            } else {
                const names = Array.from(checked).map(c => menu.querySelector(`label[for="chatTopic_${c.value}"]`).textContent);
                topicLabel = names.join(', ');
                isAllTopics = false;
            }
        }
        
        // Welcome message - All Topics is now the default
        addMessage(`🤖 AI Assistant: Welcome! I'm your DP AI Assistant. <br><b>Current Topic(s):</b> ${topicLabel}<br>Please upload compliance documents or ask a question to get started.`, 'ai', false);
        
        // Check if we have history for this session
        const history = chatHistories[sessionKey] || [];
        console.log(`[DEBUG] History length: ${history.length}`);
        
        // Display the history
        history.forEach(item => {
            console.log(`[DEBUG] Displaying history item:`, item);
            addMessage('🧑 You: ' + item.question, 'user', false, item.question_timestamp);
            
            // Format answer with sources if available
            let answerText = `🤖 <strong>AI:</strong> ${item.answer}`;
            if (item.sources && item.sources !== 'N/A' && item.sources !== 'Error occurred') {
                answerText += `<br><strong>Sources:</strong> ${item.sources}`;
            }
            addMessage(answerText, 'ai', false, item.answer_timestamp);
        });
        
        // Update chat input state based on current topic selection
        setTimeout(updateChatInputState, 100);
    }

    function setChatBarEnabled(enabled) {
        const questionInput = document.getElementById('questionInput');
        const askButton = document.getElementById('askButton');
        if (enabled) {
            questionInput.disabled = false;
            questionInput.readOnly = false;
            askButton.disabled = false;
            questionInput.classList.remove('disabled-chat-input');
            askButton.classList.remove('disabled-chat-input');
            questionInput.removeAttribute('title');
            askButton.removeAttribute('title');
        } else {
            questionInput.disabled = true;
            questionInput.readOnly = true;
            askButton.disabled = true;
            questionInput.classList.add('disabled-chat-input');
            askButton.classList.add('disabled-chat-input');
            questionInput.setAttribute('title', 'Choose a topic');
            askButton.setAttribute('title', 'Choose a topic');
        }
    }

    // Debouncing to prevent excessive API calls
    let fetchHistoryTimeout = null;
    
    function fetchChatHistory(sessionKey) {
        console.log(`[DEBUG] Fetching chat history for session: ${sessionKey}`);
        
        // SIMPLIFIED: Direct API call without debouncing to debug the issue
        fetch(`/get_history?session_key=${encodeURIComponent(sessionKey)}`)
            .then(res => {
                console.log(`[DEBUG] Fetch response status: ${res.status}`);
                return res.json();
            })
            .then(data => {
                console.log(`[DEBUG] Fetched history data:`, data);
                chatHistories[sessionKey] = data.history || [];
                console.log(`[DEBUG] Updated chatHistories[${sessionKey}]:`, chatHistories[sessionKey]);
                
                // Now display the history
                displayChatHistoryDirectly(sessionKey);
            })
            .catch(error => {
                console.error(`[ERROR] Failed to fetch chat history for session ${sessionKey}:`, error);
                // Set empty history to prevent infinite loops
                chatHistories[sessionKey] = [];
                displayChatHistoryDirectly(sessionKey);
            });
    }

    // Topic persistence using localStorage
    let selectedTopics = new Set();

    // Load saved topics from localStorage (but don't override default All Topics on page load)
    function loadSavedTopics() {
        const savedTopics = localStorage.getItem('faqBotSelectedTopics');
        if (savedTopics) {
            try {
                const topicArray = JSON.parse(savedTopics);
                selectedTopics = new Set(topicArray);
                
                // Update UI to reflect saved topics
                updateTopicCheckboxes();
                
                // Update current chat session
                currentChatSessionKey = getChatSessionKey(Array.from(selectedTopics));
                
                console.log('Loaded saved topics:', Array.from(selectedTopics));
            } catch (e) {
                console.error('Error loading saved topics:', e);
                selectedTopics = new Set(['all']);
                updateTopicCheckboxes();
            }
        } else {
            // No saved topics, default to "All Topics"
            selectedTopics = new Set(['all']);
            updateTopicCheckboxes();
        }
        
        console.log('Final selectedTopics after loadSavedTopics:', Array.from(selectedTopics));
        
        // Update chat input state after loading topics
        setTimeout(updateChatInputState, 200);
    }

    // Save topics to localStorage
    function saveTopics() {
        try {
            const topicArray = Array.from(selectedTopics);
            localStorage.setItem('faqBotSelectedTopics', JSON.stringify(topicArray));
            console.log('Saved topics to localStorage:', topicArray);
        } catch (e) {
            console.error('Error saving topics:', e);
        }
    }

    // Update topic checkboxes to reflect current selection
    function updateTopicCheckboxes() {
        const menu = document.getElementById('chatTopicsDropdownMenu');
        if (menu) {
            const checkboxes = menu.querySelectorAll('.form-check-input');
            checkboxes.forEach(checkbox => {
                if (selectedTopics.has(checkbox.value)) {
                    checkbox.checked = true;
                } else {
                    checkbox.checked = false;
                }
            });
        }
        
        // Update chat input state after updating checkboxes
        setTimeout(updateChatInputState, 100);
    }

    // Clear saved topics (useful for resetting preferences)
    function clearSavedTopics() {
        localStorage.removeItem('faqBotSelectedTopics');
        selectedTopics = new Set();
        updateTopicCheckboxes();
        currentChatSessionKey = 'topics:all';
        console.log('Cleared saved topics');
    }

    // Function to manually save current topic selection
    function saveCurrentTopics() {
        const menu = document.getElementById('chatTopicsDropdownMenu');
        if (menu) {
            const checked = menu.querySelectorAll('.form-check-input:checked');
            const selected = Array.from(checked).map(cb => cb.value);
            selectedTopics = new Set(selected);
            saveTopics();
        }
    }

            // Handle special topic selections (All Topics)
    function handleSpecialTopicSelection(checkbox) {
        const menu = document.getElementById('chatTopicsDropdownMenu');
        if (!menu) return;

        console.log(`[DEBUG] handleSpecialTopicSelection called with:`, checkbox.value, checkbox.checked);

        if (checkbox.value === 'all' && checkbox.checked) {
            // "All Topics" selected - uncheck everything else
            const checkboxes = menu.querySelectorAll('.form-check-input');
            checkboxes.forEach(cb => {
                if (cb !== checkbox) {
                    cb.checked = false;
                }
            });
            selectedTopics = new Set(['all']);
        } else if (checkbox.value !== 'all') {
            // Regular topic selected - uncheck "All Topics"
            const allCheckbox = menu.querySelector('.form-check-input[value="all"]');
            if (allCheckbox) allCheckbox.checked = false;
            
            // Update selectedTopics based on current selection
            const checked = menu.querySelectorAll('.form-check-input:checked');
            const selected = Array.from(checked).map(cb => cb.value);
            selectedTopics = new Set(selected);
        }
        
        console.log(`[DEBUG] selectedTopics updated to:`, Array.from(selectedTopics));
        
        // Save to localStorage
        saveTopics();
        
        // Update chat session
        currentChatSessionKey = getChatSessionKey(Array.from(selectedTopics));
        
        // Update chat input state based on new topic selection
        updateChatInputState();
    }

    function attachChatTopicsDropdownHandler() {
        const menu = document.getElementById('chatTopicsDropdownMenu');
        if (menu) {
            menu.addEventListener('change', function(event) {
                // Handle the change event
                if (event.target && event.target.type === 'checkbox') {
                    handleSpecialTopicSelection(event.target);
                }
                
                // Update button label
                updateBtnLabel();
                
                // Update chat session and UI
                const selected = Array.from(menu.querySelectorAll('.form-check-input:checked')).map(cb => cb.value);
                const newSessionKey = getChatSessionKey(selected);
                
                console.log(`[DEBUG] Topic selection changed:`);
                console.log(`[DEBUG]   Selected topics:`, selected);
                console.log(`[DEBUG]   Old session key: ${currentChatSessionKey}`);
                console.log(`[DEBUG]   New session key: ${newSessionKey}`);
                
                // Only update if the session key actually changed
                if (newSessionKey !== currentChatSessionKey) {
                    currentChatSessionKey = newSessionKey;
                    console.log(`[DEBUG] Session key updated to: ${currentChatSessionKey}`);
                    
                    // Always fetch fresh history for the new session
                    fetchChatHistory(currentChatSessionKey);
                } else {
                    console.log(`[DEBUG] Session key unchanged, just updating display`);
                    displayChatHistory(currentChatSessionKey);
                }
                
                // Update the Upload Questionnaire button
                updateChatInputState();
                updateUploadQuestionnaireButton();
            });
        }
    }
});

function updateStatus(state) {
    const indicator = document.getElementById('statusIndicator');
    const statusText = document.getElementById('statusText');
    if (indicator && statusText) {
        indicator.style.background = ''; // Always clear inline style first
        if (state === true || state === 'connected') {
            indicator.className = 'status-indicator status-connected';
            statusText.textContent = 'Connected';
        } else if (state === 'connecting') {
            indicator.className = 'status-indicator';
            indicator.style.background = '#ffc107'; // yellow
            statusText.textContent = 'Connecting...';
        } else if (state === 'building') {
            indicator.className = 'status-indicator status-building';
            statusText.textContent = 'Building DB';
        } else {
            indicator.className = 'status-indicator status-disconnected';
            statusText.textContent = 'Disconnected';
        }
    }
}

function initializeAI() {
    console.log('Starting AI initialization...');
    fetch('/init_ai', { method: 'POST' })
    .then(response => {
        console.log('Response status:', response.status);
        return response.json();
    })
    .then(data => {
        console.log('AI initialization response:', data);
        if (data.status === 'success' && data.ready) {
            aiInitialized = true;
            updateStatus(true);
            
            // Update chat input state based on current topic selection
            setTimeout(updateChatInputState, 100);
            
            console.log('AI initialized successfully');
        } else if (data.status === 'building') {
            updateStatus('building');
            addLogMessage('🔨 Building vector database in background...');
            // Poll for status every 2 seconds
            setTimeout(checkAIStatus, 2000);
        } else {
            updateStatus(false);
            addLogMessage('❌ Failed to initialize AI Assistant: ' + (data.error || 'Unknown error'));
            console.log('AI initialization failed:', data.error);
        }
    })
    .catch(error => {
        updateStatus(false);
        addLogMessage('❌ Error initializing AI: ' + error);
        console.log('AI initialization error:', error);
    });
}

function checkAIStatus() {
    fetch('/document_status')
    .then(response => response.json())
    .then(data => {
        if (data.ready) {
            aiInitialized = true;
            updateStatus(true);
            
            // Update chat input state based on current topic selection
            setTimeout(updateChatInputState, 100);
            
            addLogMessage('✅ AI Assistant is ready!');
            console.log('AI is ready');
        } else if (data.status === 'building') {
            updateStatus('building');
            addLogMessage('🔨 Still building vector database...');
            setTimeout(checkAIStatus, 2000);
        } else {
            updateStatus(false);
            addLogMessage('❌ AI Assistant initialization failed: ' + (data.error || 'Unknown error'));
        }
    })
    .catch(error => {
        addLogMessage('❌ Error checking AI status: ' + error);
    });
}

function setupEventListeners() {
    // Chat/Logs/Docs tab toggle
    const chatTabBtn = document.getElementById('chatTabBtn');
    const logsTabBtn = document.getElementById('logsTabBtn');
    const docsTabBtn = document.getElementById('docsTabBtn');
    
    if (chatTabBtn && logsTabBtn && docsTabBtn) {
        chatTabBtn.addEventListener('click', function() {
            document.getElementById('chatMessages').classList.remove('hidden');
            document.getElementById('logsArea').classList.add('hidden');
            document.getElementById('docsArea').classList.add('hidden');
            document.querySelector('.input-area').classList.remove('hidden');
            chatTabBtn.classList.add('active');
            logsTabBtn.classList.remove('active');
            docsTabBtn.classList.remove('active');
        });
        
        logsTabBtn.addEventListener('click', function() {
            document.getElementById('chatMessages').classList.add('hidden');
            document.getElementById('logsArea').classList.remove('hidden');
            document.getElementById('docsArea').classList.add('hidden');
            document.querySelector('.input-area').classList.remove('hidden');
            chatTabBtn.classList.remove('active');
            logsTabBtn.classList.add('active');
            docsTabBtn.classList.remove('active');
        });
        
        docsTabBtn.addEventListener('click', function() {
            document.getElementById('chatMessages').classList.add('hidden');
            document.getElementById('logsArea').classList.add('hidden');
            document.getElementById('docsArea').classList.remove('hidden');
            document.querySelector('.input-area').classList.add('hidden');
            chatTabBtn.classList.remove('active');
            logsTabBtn.classList.remove('active');
            docsTabBtn.classList.add('active');
        });
        
        // Hide input area when logs tab is active
        logsTabBtn.addEventListener('click', function() {
            document.querySelector('.input-area').classList.add('hidden');
        });
        
        // Show input area when chat tab is active
        chatTabBtn.addEventListener('click', function() {
            document.querySelector('.input-area').classList.remove('hidden');
        });
    }
    
    // Add null checks for all DOM elements
    const uploadButton = document.getElementById('uploadButton');
    const uploadPanel = document.getElementById('uploadPanel');
    const batchQnAButton = document.getElementById('batchQnAButton');
    const batchQnAPanel = document.getElementById('batchQnAPanel');
    const cancelBatchQnABtn = document.getElementById('cancelBatchQnABtn');
    const cancelUploadBtn = document.getElementById('cancelUploadBtn');
    
    // Only add event listeners if elements exist
    if (uploadButton && uploadPanel) {
        uploadButton.addEventListener('click', function() {
            uploadPanel.classList.remove('hidden');
            if (batchQnAPanel) batchQnAPanel.classList.add('hidden');
        });
    }
    
    if (batchQnAButton && batchQnAPanel) {
        batchQnAButton.addEventListener('click', function() {
            batchQnAPanel.classList.remove('hidden');
            if (uploadPanel) uploadPanel.classList.add('hidden');
        });
    }
    
    if (cancelUploadBtn && uploadPanel) {
        cancelUploadBtn.addEventListener('click', function() {
            uploadPanel.classList.add('hidden');
        });
    }
    
    if (cancelBatchQnABtn && batchQnAPanel) {
        cancelBatchQnABtn.addEventListener('click', function() {
            batchQnAPanel.classList.add('hidden');
        });
    }
    
    // Add event listeners for batch Q&A file upload
    const batchQnAInput = document.getElementById('batchQnAInput');
    const batchQnAUploadBtn = document.getElementById('batchQnAUploadBtn');
    const batchQnAFileName = document.getElementById('batchQnAFileName');
    
    if (batchQnAInput) {
        batchQnAInput.addEventListener('change', function(e) {
            const files = e.target.files;
            if (files.length > 0) {
                const fileName = files[0].name;
                batchQnAFileName.textContent = `Selected: ${fileName}`;
                batchQnAFileName.style.color = '#28a745';
                batchQnAUploadBtn.disabled = false;
            } else {
                batchQnAFileName.textContent = '';
                batchQnAUploadBtn.disabled = true;
            }
        });
    }
    
    if (batchQnAUploadBtn) {
        batchQnAUploadBtn.addEventListener('click', function() {
            const files = batchQnAInput.files;
            if (files.length === 0) {
                alert('Please select a file first.');
                return;
            }
            
            // Show loading spinner
            const loadingSpinner = document.getElementById('batchQnALoading');
            if (loadingSpinner) loadingSpinner.style.display = 'flex';
            
            // Create FormData for file upload
            const formData = new FormData();
            formData.append('file', files[0]);
            
            // Upload file and get answers
            fetch('/upload_questions', {
                method: 'POST',
                body: formData
            })
            .then(response => response.json())
            .then(data => {
                if (loadingSpinner) loadingSpinner.style.display = 'none';
                
                if (data.error) {
                    alert('Error: ' + data.error);
                } else {
                    // Start questionnaire mode to collect IDK responses
                    // startQuestionnaireMode();
                    
                    // Start progress monitoring
                    const jobId = data.job_id || 'unknown';
                    monitorQuestionnaireProgress(jobId);
                    
                    // Show initial status
                    addLogMessage(`📊 Questionnaire uploaded: ${data.questions ? data.questions.length : 0} questions found`);
                    addLogMessage(`🔄 Processing started - monitoring progress...`);
                }
            })
            .catch(error => {
                if (loadingSpinner) loadingSpinner.style.display = 'none';
                alert('Error uploading file: ' + error);
            });
        });
    }
    
    // Add event listeners for embedding test buttons
    const testEmbeddingsBtn = document.getElementById('testEmbeddingsBtn');
    const forceRebuildBtn = document.getElementById('forceRebuildBtn');
    
    if (testEmbeddingsBtn) {
        testEmbeddingsBtn.addEventListener('click', function() {
            testEmbeddings();
        });
    }
    
    if (forceRebuildBtn) {
        forceRebuildBtn.addEventListener('click', function() {
            if (confirm('Are you sure you want to force rebuild the database? This will delete the existing vector database and rebuild it with the current embedding model.')) {
                forceRebuildDB();
            }
        });
    }
}

function showInitPanel() {
    document.getElementById('initPanel').classList.remove('hidden');
    document.getElementById('uploadPanel').classList.add('hidden');
}

function hideInitPanel() {
    document.getElementById('initPanel').classList.add('hidden');
}

function showUploadPanel() {
    if (uploadPinCache) {
        const panel = document.getElementById('uploadPanel');
        if (panel) panel.classList.remove('hidden');
        return;
    }
    const pin = prompt('Enter security PIN to upload documents:');
    if (pin === UPLOAD_PIN) {
        uploadPinCache = pin;
        const panel = document.getElementById('uploadPanel');
        if (panel) panel.classList.remove('hidden');
    } else {
        alert('Incorrect PIN. Access denied.');
    }
}

function hideUploadPanel() {
    const panel = document.getElementById('uploadPanel');
    if (panel) panel.classList.add('hidden');
}

function promptForPin() {
    if (uploadPinCache) {
        showUploadPanel();
        return;
    }
    const pin = prompt('Enter security PIN to upload documents:');
    if (pin !== null) {
        if (pin === '1964') { // Default PIN from config
            uploadPinCache = pin;
            showUploadPanel();
        } else {
            alert('Incorrect PIN. Access denied.');
        }
    }
}

function handleCheckerFileSelect() {
    const files = document.getElementById('checkerFileInput').files;
    if (files.length > 0) {
        addLogMessage('📄 Selected ' + files.length + ' question document(s)');
        processCheckerFiles();
    }
}

function processCheckerFiles() {
    const files = document.getElementById('checkerFileInput').files;
    if (files.length === 0) {
        alert('Please select files to process.');
        return;
    }

    addLogMessage('🔄 Processing question documents...');
    
    // Show file names in chat
    let fileNames = [];
    for (let file of files) {
        fileNames.push(file.name);
    }
    addLogMessage('📄 Files selected: ' + fileNames.join(', '));
    
    // TODO: Implement question processing logic
                addMessage('🤖 AI: Question processing feature will be implemented soon.', 'ai', false);
}

function handleCheckerUpload() {
    // Open file picker for questionnaire upload
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.pdf,.docx,.txt,.csv,.xml';
    input.multiple = true;
    input.onchange = function(e) {
        const files = Array.from(e.target.files);
        if (files.length > 0) {
            addLogMessage('📄 Questionnaire files selected: ' + files.map(f => f.name).join(', '));
            // TODO: Implement upload to backend if needed
        }
    };
    input.click();
}

// function checkDocumentStatus() {
//     if (!aiInitialized) return;
//     fetch('/document_status', { method: 'GET' })
//     .then(response => response.json())
//     .then(data => {
//         if (data.error) {
//             addLogMessage('❌ Error checking document status: ' + data.error);
//         } else {
//             addLogMessage(`📊 Document Status: ${data.document_count} documents, Database: ${data.database_loaded ? 'Loaded' : 'Not loaded'}`);
//             if (data.documents && data.documents.length > 0) {
//                 addLogMessage('📄 Uploaded documents: ' + data.documents.join(', '));
//             } else {
//                 addLogMessage('📄 No documents uploaded yet.');
//             }
//         }
//     })
//     .catch(error => {
//         addLogMessage('❌ Error checking document status: ' + error);
//     });
// }

// Global variables to store current fetch request, abort controller, and query ID
window.currentFetchRequest = null;
window.currentAbortController = null;
window.currentQueryId = null;

function cancelCurrentQuery() {
    console.log('[DEBUG] Cancel button clicked - terminating query');
    
    // Send cancellation request to backend if we have a query ID
    if (window.currentQueryId) {
        fetch('/cancel_query', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ query_id: window.currentQueryId })
        })
        .then(response => response.json())
        .then(data => {
            console.log('[DEBUG] Backend cancellation response:', data);
        })
        .catch(error => {
            console.log('[DEBUG] Backend cancellation error:', error);
        });
    }
    
    // Abort the current fetch request if it exists
    if (window.currentAbortController) {
        window.currentAbortController.abort();
        console.log('[DEBUG] Fetch request aborted');
    }
    
    // Clear the global references
    window.currentFetchRequest = null;
    window.currentAbortController = null;
    window.currentQueryId = null;
    
    // Remove the thinking message
    const thinkingMsg = document.getElementById('thinkingMessage');
    if (thinkingMsg) thinkingMsg.remove();
    
    // Add a cancellation message
    addMessage('🚫 <strong>Query Cancelled:</strong> The AI query was cancelled by the user.', 'ai', false);
    
    // Clear any stored question data to prevent leakage
    window.currentQuestion = null;
    
    // Re-enable the input and button
    const questionInput = document.getElementById('questionInput');
    const askButton = document.getElementById('askButton');
    if (questionInput) questionInput.disabled = false;
    if (askButton) askButton.disabled = false;
    
    console.log('[DEBUG] Query cancelled and cleaned up');
}

function askQuestion() {
    const input = document.getElementById('questionInput');
    const question = input.value.trim();
    if (!question) return;
    
    // Store the current question globally for IDK alerts
    window.currentQuestion = question;
    
    // Disable input and button during processing
    input.disabled = true;
    const askButton = document.getElementById('askButton');
    if (askButton) askButton.disabled = true;
    
    addMessage('🧑 You: ' + question, 'user', true);
    input.value = '';
    // Add thinking robot message with cancel button
    const thinkingMessage = document.createElement('div');
    thinkingMessage.className = 'message ai-message';
    thinkingMessage.id = 'thinkingMessage';
    thinkingMessage.innerHTML = `
        <span style="font-size:2em">🤖</span> <em>Thinking...</em>
        <button id="cancelQueryBtn" class="btn btn-sm btn-outline-danger ms-3" style="font-size: 0.8em; padding: 4px 8px;">
            <i class="fas fa-times"></i> Cancel
        </button>
    `;
    document.getElementById('chatMessages').appendChild(thinkingMessage);
    document.getElementById('chatMessages').scrollTop = document.getElementById('chatMessages').scrollHeight;
    
    // Add cancel button event listener
    const cancelBtn = document.getElementById('cancelQueryBtn');
    if (cancelBtn) {
        cancelBtn.addEventListener('click', cancelCurrentQuery);
    }
    
    // Get the current topic selection and session key
    const topicIds = Array.from(window.selectedTopics || []);
    const sessionKey = currentChatSessionKey || 'topics:all';
    
    // Generate unique query ID for cancellation tracking
    window.currentQueryId = 'query_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    
    console.log('[DEBUG] Sending question with:', { question, topic_ids: topicIds, session_key: sessionKey, query_id: window.currentQueryId });
    
    // Create abort controller for this request
    window.currentAbortController = new AbortController();
    
    // Store the current fetch request globally so it can be aborted
    window.currentFetchRequest = fetch('/ask', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ 
            question: question,
            topic_ids: topicIds,
            session_key: sessionKey,
            query_id: window.currentQueryId
        }),
        signal: window.currentAbortController.signal
    });
    
    window.currentFetchRequest
    .then(response => response.json())
    .then(data => {
        // Clear the global fetch request, abort controller, and query ID
        window.currentFetchRequest = null;
        window.currentAbortController = null;
        window.currentQueryId = null;
        
        // Re-enable input and button
        const questionInput = document.getElementById('questionInput');
        const askButton = document.getElementById('askButton');
        if (questionInput) questionInput.disabled = false;
        if (askButton) askButton.disabled = false;
        
        // Remove thinking message
        const thinkingMsg = document.getElementById('thinkingMessage');
        if (thinkingMsg) thinkingMsg.remove();
        
        if (data.error) {
            addMessage('❌ Error: ' + data.error, 'ai', false);
        } else {
            // Create the AI response container
            let aiResponse = '🤖 <strong>AI:</strong> ';
            
            // Always show the helpful answer first
            aiResponse += '<span class="helpful-answer">' + data.answer + '</span>';
            
            // Always show the detailed answer toggle
            // aiResponse += ' <span class="detailed-toggle" onclick="toggleDetailedAnswer(this)" data-detailed="' + (data.detailed_answer || '').replace(/"/g, '&quot;').replace(/\n/g, '<br>') + '">Detailed Answer ▼</span>';
            
            // Add confidence if available
            //if (data.confidence) {
            //    aiResponse += '<br><strong>Confidence:</strong> ' + data.confidence + '%';
            //}
            
            // Add sources if available
            if (data.sources) {
                if (typeof data.sources === 'object' && data.sources.summary && data.sources.detailed) {
                    aiResponse += '<br><strong>Sources:</strong> <span class="source-summary">' + data.sources.summary + '</span> <!-- <span class="source-toggle" onclick="toggleSourceDetails(this)" data-detailed="' + data.sources.detailed.replace(/"/g, '&quot;') + '">▼</span> -->';
                } else {
                    aiResponse += '<br><strong>Sources:</strong> ' + data.sources;
                }
            }
            
            // Add safety and hallucination information
            if (data.safety_issues && data.safety_issues.length > 0) {
                aiResponse += '<br><span class="safety-warning" style="color: #d32f2f; font-weight: bold;">⚠️ SAFETY ISSUE: ' + data.safety_issues.join(', ') + '</span>';
            }
            
            if (data.is_hallucination) {
                aiResponse += '<br><span class="safety-warning" style="color: #f57c00; font-weight: bold;">⚠️ HALLUCINATION DETECTED: This answer may contain information not directly supported by the provided documents. Please verify with official sources.</span>';
            }
            
            if (data.hallucination_score > 0.3) {
                aiResponse += '<br><span class="hallucination-score" style="color: #f57c00;">🔍 Hallucination Risk Score: ' + (data.hallucination_score * 100).toFixed(1) + '%</span>';
            }
            
            addMessage(aiResponse, 'ai', true);
        }
    })
    .catch(error => {
        // Check if this is an abort error (cancelled by user)
        if (error.name === 'AbortError') {
            console.log('[DEBUG] Request was aborted by user');
            return; // Don't show error message for user-initiated cancellation
        }
        
        // Clear the global fetch request, abort controller, and query ID
        window.currentFetchRequest = null;
        window.currentAbortController = null;
        window.currentQueryId = null;
        
        // Re-enable input and button
        const questionInput = document.getElementById('questionInput');
        const askButton = document.getElementById('askButton');
        if (questionInput) questionInput.disabled = false;
        if (askButton) askButton.disabled = false;
        
        const thinkingMsg = document.getElementById('thinkingMessage');
        if (thinkingMsg) thinkingMsg.remove();
        addMessage('❌ Error: ' + error, 'ai', false);
    });
}

function uploadFiles() {
    const pin = uploadPinCache || document.getElementById('uploadPin').value;
    const files = document.getElementById('fileInput').files;
    if (!pin) {
        alert('Please enter the security PIN.');
        return;
    }
    if (files.length === 0) {
        alert('Please select files to upload.');
        return;
    }
    const formData = new FormData();
    formData.append('pin', pin);
    for (let file of files) {
        formData.append('files', file);
    }
    fetch('/upload', {
        method: 'POST',
        body: formData
    })
    .then(response => response.json())
    .then(data => {
        if (data.status === 'success') {
            addMessage('📚 Documents uploaded: ' + data.files.join(', '), 'ai', false);
            addLogMessage('📚 Documents uploaded successfully: ' + data.files.join(', '));
            addLogMessage('💾 Documents are now permanently stored and will be available in future sessions');
            hideUploadPanel();
            // Clear file input and file list
            document.getElementById('fileInput').value = '';
            document.getElementById('fileList').innerHTML = '';
        } else {
            alert('Error: ' + data.error);
            addLogMessage('❌ Upload failed: ' + data.error);
        }
    })
    .catch(error => {
        alert('Error uploading files: ' + error);
        addLogMessage('❌ Error uploading files: ' + error);
    });
}

function toggleMode() {
    if (!aiInitialized) {
        alert('Please initialize the AI Assistant first.');
        return;
    }

    showLoading('Switching modes...');

    fetch('/toggle_mode', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        }
    })
    .then(response => response.json())
    .then(data => {
        hideLoading();
        if (data.status === 'success') {
            currentMode = data.mode;
            document.getElementById('modeIndicator').textContent = 'Mode: ' + currentMode;
            addLogMessage('🔄 Switched to ' + currentMode + ' mode.');
            
            // Update interface based on mode
            if (currentMode === 'Checker') {
                document.getElementById('questionInput').placeholder = 'Ask questions or use upload button...';
                document.getElementById('checkerUploadBtn').disabled = false;
                addLogMessage('🔄 Switched to Checker mode');
            } else {
                document.getElementById('questionInput').placeholder = 'Ask your compliance question...';
                document.getElementById('checkerUploadBtn').disabled = true;
                addLogMessage('🔄 Switched to Q&A mode');
            }
            
            // Update chat input state based on current topic selection
            setTimeout(updateChatInputState, 100);
        } else {
            alert('Error: ' + data.error);
        }
    })
    .catch(error => {
        hideLoading();
        alert('Error toggling mode: ' + error);
    });
}

function exportChat() {
    const chatContent = document.getElementById('chatMessages').innerText;
    
    showLoading('Exporting chat...');

    fetch('/export_chat', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            chat_content: chatContent
        })
    })
    .then(response => response.json())
    .then(data => {
        hideLoading();
        if (data.status === 'success') {
            addMessage('💾 ' + data.message, 'ai', false);
        } else {
            alert('Error: ' + data.error);
        }
    })
    .catch(error => {
        hideLoading();
        alert('Error exporting chat: ' + error);
    });
}

function handleFileSelect() {
    const files = document.getElementById('fileInput').files;
    const fileList = document.getElementById('fileList');
    fileList.innerHTML = '';

    for (let file of files) {
        const fileItem = document.createElement('div');
        fileItem.className = 'alert alert-info';
        fileItem.innerHTML = `<i class="fas fa-file"></i> ${file.name} (${(file.size / 1024).toFixed(1)} KB)`;
        fileList.appendChild(fileItem);
    }
}

// Global IDK Questions Collector
window.idkQuestions = [];
window.isQuestionnaireMode = false;

// IDK Detection and Highlighting Functions - DISABLED FOR TESTING
// function detectIDKPatterns(text) {
//     return { hasIDK: false, highlightedText: text };
// }
        // // Direct "I don't know" statements
        // /\b(?:i\s+)?(?:don'?t\s+)?(?:know|kno)\s+(?:the\s+)?(?:answer|information|details|about\s+this)\b/gi,
        
        // // "I couldn't find that information"
        // /\b(?:i\s+)?(?:couldn'?t|could\s+not)\s+(?:find|locate)\s+(?:that\s+)?(?:information|answer|data)\b/gi,
        
        // // "I don't have information about this"
        // /\b(?:i\s+)?(?:don'?t\s+)?(?:have|possess)\s+(?:information|data|details)\s+(?:about|regarding)\s+(?:this|that|it)\b/gi,
        
        // // "I'm not able to answer this question"
        // /\b(?:i\s+)?(?:am\s+)?(?:not\s+)?(?:able|capable)\s+to\s+(?:answer|provide)\s+(?:this\s+)?(?:question|request)\b/gi,
        
        // // "I cannot answer this question"
        // /\b(?:i\s+)?(?:cannot|cant|can'?t)\s+(?:answer|provide|give)\s+(?:this\s+)?(?:question|query|request)\b/gi,
        
        // // "No information found for this"
        // /\b(?:no\s+)?(?:information|data|details)\s+(?:found|available)\s+(?:for|about|regarding)\s+(?:this|that|it)\b/gi,
        
        // // "I'm not sure about this"
        // /\b(?:i\s+)?(?:am\s+)?(?:not\s+)?(?:sure|certain)\s+(?:about|regarding)\s+(?:this|that|it)\b/gi,
        
        // // "I cannot determine this"
        // /\b(?:i\s+)?(?:cannot|cant|can'?t)\s+determine\s+(?:this|that|it)\b/gi,
        
        // // "This is not covered in the documents"
        // /\b(?:this\s+)?(?:is\s+)?(?:not\s+)?(?:covered|addressed|mentioned)\s+(?:in|by|within)\s+(?:the\s+)?(?:documents|materials|sources)\b/gi,
        
        // // "I have no knowledge about this"
        // /\b(?:i\s+)?(?:have\s+)?(?:no\s+)?(?:knowledge|information)\s+(?:about|regarding)\s+(?:this|that|it)\b/gi,
        
        // // NEW: "I don't have specific information"
        // /\b(?:i\s+)?(?:don'?t\s+)?(?:have|possess)\s+(?:specific|detailed|particular)\s+(?:information|data|details)\b/gi,
        
        // // NEW: "I apologize, but I cannot provide"
        // /\b(?:i\s+)?(?:apologize|apologise|sorry)\s*,?\s*(?:but\s+)?(?:i\s+)?(?:cannot|cant|can'?t)\s+(?:provide|give|offer)\b/gi,
        
        // // NEW: "I'm unable to provide"
        // /\b(?:i\s+)?(?:am\s+)?(?:unable|not\s+able)\s+to\s+(?:provide|give|offer|answer)\b/gi,
        
        // // NEW: "This information is not available"
        // /\b(?:i\s+)?(?:this\s+)?(?:information|data|details)\s+(?:is\s+)?(?:not\s+)?(?:available|accessible|obtainable)\b/gi,
        
        // // NEW: "I cannot find specific details"
        // /\b(?:i\s+)?(?:cannot|cant|can'?t)\s+(?:find|locate|identify)\s+(?:specific|detailed|particular)\s+(?:details|information|data)\b/gi,
        
        // // NEW: "This falls outside my knowledge"
        // /\b(?:this\s+)?(?:falls|lies)\s+(?:outside|beyond)\s+(?:my\s+)?(?:knowledge|expertise|scope)\b/gi,
        
        // // NEW: "I don't have access to this information"
        // /\b(?:i\s+)?(?:don'?t\s+)?(?:have|possess)\s+(?:access\s+to|access\s+to\s+the)\s+(?:this\s+)?(?:information|data|details)\b/gi,
        
        // // ADDITIONAL: General "I don't have" patterns
        // /\b(?:i\s+)?(?:don'?t\s+)?(?:have|possess)\s+(?:any\s+)?(?:information|data|details|knowledge|context)\b/gi,
        
        // // ADDITIONAL: "I don't have anything about"
        // /\b(?:i\s+)?(?:don'?t\s+)?(?:have|possess)\s+(?:anything|something|any\s+details)\s+(?:about|regarding|concerning)\b/gi,
        
        // // ADDITIONAL: "I don't have the information"
        // /\b(?:i\s+)?(?:don'?t\s+)?(?:have|possess)\s+(?:the\s+)?(?:information|data|details|knowledge)\b/gi,
        
        // // ADDITIONAL: "I don't have enough information"
        // /\b(?:i\s+)?(?:don'?t\s+)?(?:have|possess)\s+(?:enough|sufficient|adequate)\s+(?:information|data|details|knowledge)\b/gi,
        
        // // ADDITIONAL: "I don't have that information"
        // /\b(?:i\s+)?(?:don'?t\s+)?(?:have|possess)\s+(?:that|this|the)\s+(?:information|data|details|knowledge)\b/gi,
        
        // // ADDITIONAL: "I don't have any details"
        // /\b(?:i\s+)?(?:don'?t\s+)?(?:have|possess)\s+(?:any\s+)?(?:details|specifics|particulars)\b/gi,
        
        // // ADDITIONAL: "I don't have the answer"
        // /\b(?:i\s+)?(?:don'?t\s+)?(?:have|possess)\s+(?:the\s+)?(?:answer|solution|response)\b/gi,
        
        // // ADDITIONAL: "I don't have a response"
        // /\b(?:i\s+)?(?:don'?t\s+)?(?:have|possess)\s+(?:a\s+)?(?:response|answer|solution)\b/gi,
        
        // // ADDITIONAL: "I don't have the context"
        // /\b(?:i\s+)?(?:don'?t\s+)?(?:have|possess)\s+(?:the\s+)?(?:context|background|framework)\b/gi,
        
        // // ADDITIONAL: "I don't have the background"
        // /\b(?:i\s+)?(?:don'?t\s+)?(?:have|possess)\s+(?:the\s+)?(?:background|context|history)\b/gi,
        
        // // ADDITIONAL: "I don't have the details"
        // /\b(?:i\s+)?(?:don'?t\s+)?(?:have|possess)\s+(?:the\s+)?(?:details|particulars|specifics)\b/gi,
        
        // // ADDITIONAL: "I don't have the specifics"
        // /\b(?:i\s+)?(?:don'?t\s+)?(?:have|possess)\s+(?:the\s+)?(?:specifics|details|particulars)\b/gi,
        
        // // ADDITIONAL: "I don't have the particulars"
        // /\b(?:i\s+)?(?:don'?t\s+)?(?:have|possess)\s+(?:the\s+)?(?:particulars|details|specifics)\b/gi,
        
        // // ADDITIONAL: "I don't have the knowledge"
        // /\b(?:i\s+)?(?:don'?t\s+)?(?:have|possess)\s+(?:the\s+)?(?:knowledge|understanding|expertise)\b/gi,
        
        // // ADDITIONAL: "I don't have the understanding"
        // /\b(?:i\s+)?(?:don'?t\s+)?(?:have|possess)\s+(?:the\s+)?(?:understanding|knowledge|comprehension)\b/gi,
        
        // ADDITIONAL: "I don't have the expertise"
        // /\b(?:i\s+)?(?:don'?t\s+)?(?:have|possess)\s+(?:the\s+)?(?:expertise|knowledge|skills)\b/gi,
        
        // ADDITIONAL: "I don't have the skills"
        // /\b(?:i\s+)?(?:don'?t\s+)?(?:have|possess)\s+(?:the\s+)?(?:skills|abilities|capabilities)\b/gi,
        
        // ADDITIONAL: "I don't have the capabilities"
        // /\b(?:i\s+)?(?:don'?t\s+)?(?:have|possess)\s+(?:the\s+)?(?:capabilities|abilities|skills)\b/gi,
        
        // ADDITIONAL: "I don't have the abilities"
        // /\b(?:i\s+)?(?:don'?t\s+)?(?:have|possess)\s+(?:the\s+)?(?:abilities|skills|capabilities)\b/gi,
        
        // ADDITIONAL: "I don't have the resources"
        // /\b(?:i\s+)?(?:don'?t\s+)?(?:have|possess)\s+(?:the\s+)?(?:resources|materials|tools)\b/gi,
        
        // ADDITIONAL: "I don't have the materials"
        // /\b(?:i\s+)?(?:don'?t\s+)?(?:have|possess)\s+(?:the\s+)?(?:materials|resources|tools)\b/gi,
        
        // ADDITIONAL: "I don't have the tools"
        // /\b(?:i\s+)?(?:don'?t\s+)?(?:have|possess)\s+(?:the\s+)?(?:tools|resources|materials)\b/gi,
        
        // ADDITIONAL: "I don't have the data"
        // /\b(?:i\s+)?(?:don'?t\s+)?(?:have|possess)\s+(?:the\s+)?(?:data|information|facts)\b/gi,
        
        // ADDITIONAL: "I don't have the facts"
        // /\b(?:i\s+)?(?:don'?t\s+)?(?:have|possess)\s+(?:the\s+)?(?:facts|data|information)\b/gi,
        
        // ADDITIONAL: "I don't have the evidence"
        // /\b(?:i\s+)?(?:don'?t\s+)?(?:have|possess)\s+(?:the\s+)?(?:evidence|proof|support)\b/gi,
        
        // ADDITIONAL: "I don't have the proof"
        // /\b(?:i\s+)?(?:don'?t\s+)?(?:have|possess)\s+(?:the\s+)?(?:proof|evidence|support)\b/gi,
        
        // ADDITIONAL: "I don't have the support"
        // /\b(?:i\s+)?(?:don'?t\s+)?(?:have|possess)\s+(?:the\s+)?(?:support|evidence|proof)\b/gi,
        
        // ADDITIONAL: "I don't have the documentation"
        // /\b(?:i\s+)?(?:don'?t\s+)?(?:have|possess)\s+(?:the\s+)?(?:documentation|records|files)\b/gi,
        
        // ADDITIONAL: "I don't have the records"
        // /\b(?:i\s+)?(?:don'?t\s+)?(?:have|possess)\s+(?:the\s+)?(?:records|documentation|files)\b/gi,
        
        // ADDITIONAL: "I don't have the files"
        // /\b(?:i\s+)?(?:don'?t\s+)?(?:have|possess)\s+(?:the\s+)?(?:files|documentation|records)\b/gi,
        
        // ADDITIONAL: "I don't have the sources"
        // /\b(?:i\s+)?(?:don'?t\s+)?(?:have|possess)\s+(?:the\s+)?(?:sources|references|citations)\b/gi,
        
        // ADDITIONAL: "I don't have the references"
        // /\b(?:i\s+)?(?:don'?t\s+)?(?:have|possess)\s+(?:the\s+)?(?:references|sources|citations)\b/gi,
        
        // ADDITIONAL: "I don't have the citations"
        // /\b(?:i\s+)?(?:don'?t\s+)?(?:have|possess)\s+(?:the\s+)?(?:citations|references|sources)\b/gi,
        
        // ADDITIONAL: "I don't have enough context"
        // /\b(?:i\s+)?(?:don'?t\s+)?(?:have|possess)\s+(?:enough|sufficient|adequate)\s+(?:context|background|framework)\b/gi,
        
        // ADDITIONAL: "I don't have the framework"
        // /\b(?:i\s+)?(?:don'?t\s+)?(?:have|possess)\s+(?:the\s+)?(?:framework|structure|outline)\b/gi,
        
        // ADDITIONAL: "I don't have the structure"
        // /\b(?:i\s+)?(?:don'?t\s+)?(?:have|possess)\s+(?:the\s+)?(?:structure|framework|outline)\b/gi,
        
        // ADDITIONAL: "I don't have the outline"
        // /\b(?:i\s+)?(?:don'?t\s+)?(?:have|possess)\s+(?:the\s+)?(?:outline|structure|framework)\b/gi,
        
        // ADDITIONAL: "I don't have the history"
        // /\b(?:i\s+)?(?:don'?t\s+)?(?:have|possess)\s+(?:the\s+)?(?:history|background|timeline)\b/gi,
        
        // ADDITIONAL: "I don't have the timeline"
        // /\b(?:i\s+)?(?:don'?t\s+)?(?:have|possess)\s+(?:the\s+)?(?:timeline|history|chronology)\b/gi,
        
        // ADDITIONAL: "I don't have the chronology"
        // /\b(?:i\s+)?(?:don'?t\s+)?(?:have|possess)\s+(?:the\s+)?(?:chronology|timeline|sequence)\b/gi,
        
        // ADDITIONAL: "I don't have the sequence"
        // /\b(?:i\s+)?(?:don'?t\s+)?(?:have|possess)\s+(?:the\s+)?(?:sequence|order|progression)\b/gi,
        
        // ADDITIONAL: "I don't have the order"
        // /\b(?:i\s+)?(?:don'?t\s+)?(?:have|possess)\s+(?:the\s+)?(?:order|sequence|progression)\b/gi,
        
        // ADDITIONAL: "I don't have the progression"
        // /\b(?:i\s+)?(?:don'?t\s+)?(?:have|possess)\s+(?:the\s+)?(?:progression|sequence|order)\b/gi,
        
        // ADDITIONAL: "I don't have the basis"
        // /\b(?:i\s+)?(?:don'?t\s+)?(?:have|possess)\s+(?:the\s+)?(?:basis|foundation|grounds)\b/gi,
        
        // ADDITIONAL: "I don't have the foundation"
        // /\b(?:i\s+)?(?:don'?t\s+)?(?:have|possess)\s+(?:the\s+)?(?:foundation|basis|grounds)\b/gi,
        
        // ADDITIONAL: "I don't have the grounds"
        // /\b(?:i\s+)?(?:don'?t\s+)?(?:have|possess)\s+(?:the\s+)?(?:grounds|basis|foundation)\b/gi,
        
        // ADDITIONAL: "I don't have the reason"
        // /\b(?:i\s+)?(?:don'?t\s+)?(?:have|possess)\s+(?:the\s+)?(?:reason|justification|explanation)\b/gi,
        
        // ADDITIONAL: "I don't have the justification"
        // /\b(?:i\s+)?(?:don'?t\s+)?(?:have|possess)\s+(?:the\s+)?(?:justification|reason|explanation)\b/gi,
        
        // ADDITIONAL: "I don't have the explanation"
        // /\b(?:i\s+)?(?:don'?t\s+)?(?:have|possess)\s+(?:the\s+)?(?:explanation|reason|justification)\b/gi,
        
        // ADDITIONAL: "I don't have the insight"
        // /\b(?:i\s+)?(?:don'?t\s+)?(?:have|possess)\s+(?:the\s+)?(?:insight|understanding|perspective)\b/gi,
        
        // ADDITIONAL: "I don't have the perspective"
        // /\b(?:i\s+)?(?:don'?t\s+)?(?:have|possess)\s+(?:the\s+)?(?:perspective|insight|viewpoint)\b/gi,
        
        // ADDITIONAL: "I don't have the viewpoint"
        // /\b(?:i\s+)?(?:don'?t\s+)?(?:have|possess)\s+(?:the\s+)?(?:viewpoint|perspective|insight)\b/gi,
        
        // ADDITIONAL: "I don't have the experience"
        // /\b(?:i\s+)?(?:don'?t\s+)?(?:have|possess)\s+(?:the\s+)?(?:experience|practice|exposure)\b/gi,
        
        // ADDITIONAL: "I don't have the practice"
        // /\b(?:i\s+)?(?:don'?t\s+)?(?:have|possess)\s+(?:the\s+)?(?:practice|experience|exposure)\b/gi,
        
        // ADDITIONAL: "I don't have the exposure"
        // /\b(?:i\s+)?(?:don'?t\s+)?(?:have|possess)\s+(?:the\s+)?(?:exposure|experience|practice)\b/gi
    // ];
    
    // let hasIDK = false;
    // let highlightedText = text;
    
    // // Check each pattern with more strict matching
    // idkPatterns.forEach(pattern => {
    //     if (pattern.test(text)) {
    //         hasIDK = true;
    //         // Highlight the matched text
    //         highlightedText = highlightedText.replace(pattern, (match) => {
    //         return `<span class="idk-highlight">${match}</span>`;
    //         });
    //     }
    // });
    
    // return { hasIDK, highlightedText };
//     return { hasIDK: false, highlightedText: text };
// }

// function showIDKAlert(question = '') {
//     // Create overlay
//     const overlay = document.createElement('div');
//     overlay.className = 'idk-overlay';
//     document.body.appendChild(overlay);
    
    // // Create alert modal
    // const modal = document.createElement('div');
    // modal.className = 'idk-alert-modal';
    
    // // Check if we have multiple IDK questions (questionnaire mode)
    // const hasMultipleQuestions = window.idkQuestions.length > 1;
    // const questionCount = window.idkQuestions.length;
    
    // let modalContent = '';
    
    // if (hasMultipleQuestions) {
    //     // Multiple questions mode - show count and list option
    //     modalContent = `
    //         <h3>Human Attention Needed</h3>
    //         <p><strong>AI Answered IDK to ${questionCount} Questions</strong><br><br>
    //         The AI has indicated it doesn't know the answer to ${questionCount} questions during questionnaire processing. 
    //         This may require human review or additional context.</p>
    //         <div class="idk-alert-buttons">
    //             <button onclick="showIDKDetailsList()" class="btn-details">View All Questions (${questionCount})</button>
    //             <button onclick="closeIDKAlert()" class="btn-acknowledge">Acknowledge</button>
    //         </div>
    //     `;
    // } else {
    //     // Single question mode - show individual question
    //     modalContent = `
    //         <h3>Human Attention Needed</h3>
    //         <p><strong>AI Answered IDK</strong><br><br>
    //         The AI has indicated it doesn't know the answer to this question. 
    //         This may require human review or additional context.</p>
    //         <div class="idk-alert-buttons">
    //             <button onclick="showIDKDetails('${question.replace(/'/g, "\\'")}')" class="btn-details">Details</button>
    //             <button onclick="closeIDKAlert()" class="btn-acknowledge">Acknowledge</button>
    //         </div>
    //     `;
    // }
    
    // modal.innerHTML = modalContent;
    // document.body.appendChild(modal);
    
    // // Alert will only close when user clicks Acknowledge
// }

// function closeIDKAlert() {
//     const overlay = document.querySelector('.idk-overlay');
//     const modal = document.querySelector('.idk-alert-modal');
    
//     if (overlay) overlay.remove();
//     if (modal) modal.remove();
// }

// function showIDKDetails(question) {
//     // Create details modal for single question
//     const detailsModal = document.createElement('div');
//     detailsModal.className = 'idk-details-modal';
//     detailsModal.innerHTML = `
//         <div class="idk-details-content">
//             <h4>📝 Question Details</h4>
//             <p><strong>Question:</strong></p>
//             <div class="question-text">${question}</div>
//             <button onclick="closeIDKDetails()" class="btn-close">Close</button>
//         </div>
//     `;
//     document.body.appendChild(detailsModal);
// }

// function showIDKDetailsList() {
//     // Create details modal for multiple questions
//     const detailsModal = document.createElement('div');
//     detailsModal.className = 'idk-details-modal';
    
//     let questionsList = '';
//     window.idkQuestions.forEach((item, index) => {
//         questionsList += `
//             <div class="question-item">
//                 <div class="question-header">
//                     <span class="question-number">${index + 1}</span>
//                     <span class="question-time">${item.timestamp}</span>
//                 </div>
//                 <div class="question-text">${item.question}</div>
//                 <div class="ai-response">${item.response}</div>
//             </div>
//         `;
//     });
    
//     detailsModal.innerHTML = `
//         <div class="idk-details-content">
//             <h4>📝 IDK Questions Summary (${window.idkQuestions.length})</h4>
//             <div class="questions-list">
//                 ${questionsList}
//             </div>
//             <div class="modal-actions">
//                 <button onclick="clearIDKQuestions()" class="btn-clear">Clear List</button>
//                 <button onclick="closeIDKDetails()" class="btn-close">Close</button>
//             </div>
//         </div>
//     `;
//     document.body.appendChild(detailsModal);
// }

// function closeIDKDetails() {
//     const detailsModal = document.querySelector('.idk-details-modal');
//     if (detailsModal) detailsModal.remove();
// }

// function clearIDKQuestions() {
//     window.idkQuestions = [];
//     closeIDKDetails();
//     addLogMessage('✅ IDK questions list cleared');
// }





// IDK Management Functions - DISABLED FOR TESTING
// function startQuestionnaireMode() {
//     window.isQuestionnaireMode = true;
//     window.idkQuestions = []; // Clear previous questions
//     addLogMessage('📋 Questionnaire mode started - IDK alerts will be collected and shown at the end');
// }

// function endQuestionnaireMode() {
//     window.isQuestionnaireMode = false;
    
//     // Show final IDK alert if there are any questions
//     if (window.idkQuestions.length > 0) {
//         setTimeout(() => {
//             showIDKAlert(); // This will show the multiple questions alert
//         }, 1000);
//         addLogMessage(`🚨 Questionnaire completed with ${window.idkQuestions.length} IDK responses`);
//     } else {
//         addLogMessage('✅ Questionnaire completed successfully - no IDK responses');
//     }
// }

function addMessage(text, type, isNewMessage = false, timestamp = null) {
    const chatMessages = document.getElementById('chatMessages');
    const messageDiv = document.createElement('div');
    messageDiv.className = `message ${type}-message`;
    
    // Format timestamp - always show timestamp in PST
    let timestampHtml = '';
    const timestampToUse = timestamp || new Date().toISOString();
    const date = new Date(timestampToUse);
    const timeStr = date.toLocaleTimeString('en-US', { 
        hour: '2-digit', 
        minute: '2-digit',
        timeZone: 'America/Los_Angeles'
    });
    const dateStr = date.toLocaleDateString('en-US', { 
        month: 'short', 
        day: 'numeric',
        timeZone: 'America/Los_Angeles'
    });
    timestampHtml = `<div class="message-timestamp">${dateStr} ${timeStr} PST</div>`;
    console.log('[DEBUG] Adding timestamp:', timestampHtml);
    
    // IDK Detection - DISABLED FOR TESTING
    // if (type === 'ai' && isNewMessage) {
    //     const { hasIDK, highlightedText } = detectIDKPatterns(text);
    //     messageDiv.innerHTML = highlightedText;
        
    //     // Collect IDK questions instead of showing alerts immediately
    //     if (hasIDK) {
    //         const question = window.currentQuestion || 'Question not available';
            
    //         // Add to IDK questions list if not already there
    //         if (!window.idkQuestions.some(q => q.question === question)) {
    //             window.idkQuestions.push({
    //                 question: question,
    //                 timestamp: new Date().toLocaleTimeString(),
    //                 response: text
    //             });
    //         }
            
    //         // Only show alert immediately if NOT in questionnaire mode
    //         if (!window.isQuestionnaireMode) {
    //             setTimeout(() => {
    //                 showIDKAlert(question);
    //             }, 300);
    //         }
    //     }
    // } else {
    //     // For history display or non-AI messages, just show the text without IDK detection
    //     messageDiv.innerHTML = text;
    // }
    
    // Simplified message display without IDK detection
    messageDiv.innerHTML = text + timestampHtml;
    
    chatMessages.appendChild(messageDiv);
    chatMessages.scrollTop = chatMessages.scrollHeight;
}

function addLogMessage(text, id = null) {
    const logsArea = document.getElementById('logsArea');
    const messageDiv = document.createElement('div');
    messageDiv.className = 'message ai-message';
    if (id) {
        messageDiv.id = id;
    }
    const timestamp = new Date().toLocaleTimeString();
    messageDiv.innerHTML = `<strong>📋</strong> [${timestamp}] ${text}`;
    logsArea.appendChild(messageDiv);
    logsArea.scrollTop = logsArea.scrollHeight;
    return messageDiv;
}

function testEmbeddings() {
    addLogMessage('🧠 Testing embedding model configuration...');
    
    fetch('/test_embeddings')
        .then(response => response.json())
        .then(data => {
            if (data.status === 'success') {
                const info = data.embedding_info;
                addLogMessage(`✅ Embedding Model Test Results:`);
                addLogMessage(`   • Type: ${info.embedding_type}`);
                addLogMessage(`   • Has BGE Model: ${info.has_bge_model}`);
                addLogMessage(`   • BGE Model is None: ${info.bge_model_is_none}`);
                addLogMessage(`   • Embedding Class: ${info.embedding_class}`);
                addLogMessage(`   • Config Model: ${info.config_model}`);
                addLogMessage(`   • Config EMBEDDING_MODEL: ${info.config_embedding_model}`);
                
                if (info.embedding_type === 'configured' && !info.bge_model_is_none) {
                    addLogMessage('🎯 SUCCESS: Using configured embedding model!');
                } else {
                    addLogMessage('⚠️ WARNING: Not using configured embedding model!');
                }
            } else {
                addLogMessage(`❌ Error testing embeddings: ${data.message}`);
            }
        })
        .catch(error => {
            addLogMessage(`❌ Error testing embeddings: ${error.message}`);
        });
}

function forceRebuildDB() {
    addLogMessage('🔄 Starting forced database rebuild...');
    
    fetch('/force_rebuild_db', { method: 'POST' })
        .then(response => response.json())
        .then(data => {
            if (data.status === 'success') {
                addLogMessage('✅ Database rebuild started successfully!');
                addLogMessage('🔄 The system will rebuild the vector database with the current embedding model.');
                addLogMessage('⏳ This may take several minutes. Check the status indicator for progress.');
                
                // Update status to show rebuilding
                updateStatus('building');
            } else {
                addLogMessage(`❌ Error starting rebuild: ${data.message}`);
            }
        })
        .catch(error => {
            addLogMessage(`❌ Error starting rebuild: ${error.message}`);
        });
}

function updateLogMessage(id, text) {
    const messageDiv = document.getElementById(id);
    if (messageDiv) {
        const timestamp = new Date().toLocaleTimeString();
        messageDiv.innerHTML = `<strong>📋</strong> [${timestamp}] ${text}`;
    }
}

function showLoading(text) {
    document.getElementById('loadingText').textContent = text;
    document.getElementById('loadingOverlay').style.display = 'flex';
}

function hideLoading() {
    document.getElementById('loadingOverlay').style.display = 'none';
}

// Shared user system - no authentication needed
const userStatusText = document.getElementById('userStatusText2');
const clearHistoryBtn = document.getElementById('clearHistoryBtn');

// Always show shared user status
function setSharedUserStatus() {
    userStatusText.textContent = 'Shared User';
    window.isLoggedInUser = true;  // Always treat as logged-in user
}

// Login functionality removed - no longer needed with shared user system

// Register functionality removed - no longer needed with shared user system

// Logout functionality removed - no longer needed with shared user system

// Clear history functionality
clearHistoryBtn.addEventListener('click', function() {
    showClearHistoryModal();
});

// Export history functionality
document.getElementById('exportBtn').addEventListener('click', function() {
    fetch('/export_history', {method: 'POST'})
    .then(response => {
        if (!response.ok) throw new Error('Failed to export history');
        return response.blob();
    })
    .then(blob => {
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'chat_history.csv';
        document.body.appendChild(a);
        a.click();
        a.remove();
        window.URL.revokeObjectURL(url);
    })
    .catch(err => {
        alert('Error exporting history: ' + err.message);
    });
});

// --- Document Management UI Logic ---
const addDocBtn = document.getElementById('addDocBtn');
const addDocInput = document.getElementById('addDocInput');
const docsTableBody = document.getElementById('docsTableBody');
const bulkDeleteBtn = document.getElementById('bulkDeleteBtn');
const bulkReplaceBtn = document.getElementById('bulkReplaceBtn');
const bulkReplaceInput = document.getElementById('bulkReplaceInput');
const selectAllCheckbox = document.getElementById('selectAllCheckbox');

let docsList = [];
// Multi-level sort state
let sortLevels = [{ column: 'topics', direction: 'asc' }];
const sortableColumns = ['topics', 'name', 'type', 'uploaded'];

function renderDocsTableHeader() {
    const thead = document.querySelector('#docsTableBody').parentElement.querySelector('thead');
    if (!thead) return;
    const headerRow = thead.querySelector('tr');
    if (!headerRow) return;
    const columns = [
        { key: 'select', label: '' },
        { key: 'name', label: 'Name' },
        { key: 'topics', label: 'Tags' },
        { key: 'type', label: 'Type' },
        { key: 'uploaded', label: 'Uploaded' },
        { key: 'actions', label: 'Rename' }
    ];
    headerRow.innerHTML = '';
    columns.forEach(col => {
        let th = document.createElement('th');
        th.style.width = col.key === 'select' ? '50px' : (col.key === 'actions' ? '120px' : '');
        if (sortableColumns.includes(col.key)) {
            // Find sort level for this column
            const sortIdx = sortLevels.findIndex(s => s.column === col.key);
            let arrow = '';
            if (sortIdx !== -1) {
                arrow = `<span class="sort-arrow" data-col="${col.key}" data-level="${sortIdx+1}" style="cursor:pointer;">${sortLevels[sortIdx].direction === 'asc' ? '▲' : '▼'}<sup>${sortIdx+1}</sup></span>`;
            } else {
                arrow = `<span class="sort-arrow" data-col="${col.key}" style="opacity:0.3;cursor:pointer;">▲</span>`;
            }
            th.innerHTML = `${col.label} ${arrow}`;
        } else {
            th.textContent = col.label;
        }
        headerRow.appendChild(th);
    });
    // Add event listeners for sorting only to the arrows
    headerRow.querySelectorAll('.sort-arrow').forEach(arrow => {
        let hoverTimeout = null;
        arrow.addEventListener('mouseenter', function() {
            hoverTimeout = setTimeout(() => {
                const col = this.getAttribute('data-col');
                const idx = sortLevels.findIndex(s => s.column === col);
                if (idx !== -1) {
                    // Duplicate the arrow n times for nth order
                    this.innerHTML = `${sortLevels[idx].direction === 'asc' ? '▲' : '▼'}<sup>${idx+1}</sup>`.repeat(idx+1);
                }
            }, 2000);
        });
        arrow.addEventListener('mouseleave', function() {
            clearTimeout(hoverTimeout);
            renderDocsTableHeader();
        });
        arrow.addEventListener('click', function(e) {
            const col = this.getAttribute('data-col');
            const idx = sortLevels.findIndex(s => s.column === col);
            if (idx !== -1) {
                // Toggle direction if not shift, or move to last if shift
                if (e.shiftKey) {
                    const [item] = sortLevels.splice(idx, 1);
                    sortLevels.push(item);
                } else {
                    sortLevels[idx].direction = sortLevels[idx].direction === 'asc' ? 'desc' : 'asc';
                }
            } else {
                sortLevels.push({ column: col, direction: 'asc' });
            }
            renderDocsTableHeader();
            loadDocuments();
        });
    });
}

function renderDocsTable() {
    docsTableBody.innerHTML = '';
    if (docsList.length === 0) {
        docsTableBody.innerHTML = '<tr><td colspan="6" class="text-center text-muted">No documents uploaded yet.</td></tr>';
        return;
    }
    // Sort docsList according to sortLevels
    docsList.sort((a, b) => {
        for (let { column, direction } of sortLevels) {
            let av = a[column], bv = b[column];
            // For topics, compare as comma-joined string
            if (column === 'topics') {
                av = (a.tags || []).join(',');
                bv = (b.tags || []).join(',');
            }
            // For name, compare lower-case
            if (column === 'name') {
                av = av ? av.toLowerCase() : '';
                bv = bv ? bv.toLowerCase() : '';
            }
            if (av < bv) return direction === 'asc' ? -1 : 1;
            if (av > bv) return direction === 'asc' ? 1 : -1;
        }
        return 0;
    });
    docsList.forEach(doc => {
        const tr = document.createElement('tr');
        const fileSize = (doc.size / 1024).toFixed(1) + ' KB';
        const tags = doc.tags || [];
        const tagsHtml = tags.length > 0 ? 
            tags.map(tag => `<span class="badge bg-primary me-1">${tag}</span>`).join('') : 
            '<span class="text-muted">No tags</span>';
        tr.innerHTML = `
            <td>
                <input type="checkbox" class="form-check-input doc-checkbox" value="${doc.name}">
            </td>
            <td>${doc.name}</td>
            <td class="editable-topics" data-filename="${doc.name}" data-tags='${JSON.stringify(tags)}' style="cursor: pointer;" title="Double-click to edit topics">
                <div class="topics-container">
                    ${tagsHtml}
                </div>
            </td>
            <td>${doc.type}</td>
            <td>${doc.uploaded}</td>
            <td>
                <button class="btn btn-sm btn-outline-primary rename-doc-btn" data-filename="${doc.name}" title="Rename">
                    <i class="fas fa-edit"></i>
                </button>
            </td>
        `;
        docsTableBody.appendChild(tr);
    });
    
    // Add event listeners to checkboxes
    const checkboxes = document.querySelectorAll('.doc-checkbox');
    checkboxes.forEach(checkbox => {
        checkbox.addEventListener('change', updateBulkButtons);
    });
    
    // Add event listeners to rename buttons
    const renameButtons = document.querySelectorAll('.rename-doc-btn');
    renameButtons.forEach(button => {
        button.addEventListener('click', function() {
            const filename = this.getAttribute('data-filename');
            showRenameModal(filename);
        });
    });
    
    // Add event listeners to editable topics (double-click)
    const editableTopics = document.querySelectorAll('.editable-topics');
    editableTopics.forEach(topicCell => {
        topicCell.addEventListener('dblclick', function() {
            const filename = this.getAttribute('data-filename');
            const currentTags = JSON.parse(this.getAttribute('data-tags') || '[]');
            showEditTopicsModal(filename, currentTags);
        });
    });
    
    if (pendingAnimationStop) { setTimeout(pendingAnimationStop, 1500); pendingAnimationStop = null; }
}

function updateBulkButtons() {
    const selectedCheckboxes = document.querySelectorAll('.doc-checkbox:checked');
    const hasSelection = selectedCheckboxes.length > 0;
    
    bulkDeleteBtn.disabled = !hasSelection;
    bulkReplaceBtn.disabled = !hasSelection;
    
    // Update select all checkbox
    const allCheckboxes = document.querySelectorAll('.doc-checkbox');
    const allChecked = allCheckboxes.length > 0 && allCheckboxes.length === selectedCheckboxes.length;
    selectAllCheckbox.checked = allChecked;
    selectAllCheckbox.indeterminate = selectedCheckboxes.length > 0 && selectedCheckboxes.length < allCheckboxes.length;
}

function getSelectedDocuments() {
    const selectedCheckboxes = document.querySelectorAll('.doc-checkbox:checked');
    return Array.from(selectedCheckboxes).map(cb => cb.value);
}

function loadDocuments() {
    const cacheBuster = Date.now();
    // Get selected topics from Docs Management dropdown
    let localSelectedTopics = [];
    const topicDropdownMenu = document.getElementById('topicDropdownMenu');
    if (topicDropdownMenu) {
        localSelectedTopics = Array.from(topicDropdownMenu.querySelectorAll('.topic-checkbox:checked')).map(cb => cb.value);
    }
    let topic = 'all';
    let selected_topics_param = '';
    if (localSelectedTopics.length === 1 && localSelectedTopics[0] !== 'all') {
        topic = localSelectedTopics[0];
    } else if (localSelectedTopics.length > 1) {
        topic = 'multiple';
        // Always send sorted array of integers
        const sortedInts = localSelectedTopics.filter(v => v !== 'all').map(v => parseInt(v, 10)).sort((a, b) => a - b);
        selected_topics_param = `&selected_topics=${JSON.stringify(sortedInts)}`;
    }
    let url = `/get_documents?cb=${cacheBuster}&topic=${topic}${selected_topics_param}`;
    // Send sortLevels as a query param
    if (sortLevels.length > 0) {
        const sortParam = sortLevels.map(s => `${s.column}:${s.direction}`).join(',');
        url += `&sort=${encodeURIComponent(sortParam)}`;
    }
    docsTableBody.innerHTML = '<tr><td colspan="6" class="text-center text-muted">Loading documents...</td></tr>';
    fetch(url)
        .then(response => response.json())
        .then(data => {
            if (data.documents) {
                docsList = data.documents;
                renderDocsTableHeader();
                renderDocsTable();
                updateBulkButtons();
            } else {
                docsTableBody.innerHTML = '<tr><td colspan="6" class="text-center text-muted">Error loading documents</td></tr>';
            }
        })
        .catch(error => {
            docsTableBody.innerHTML = '<tr><td colspan="6" class="text-center text-muted">Error loading documents</td></tr>';
        });
}

// Select all checkbox functionality
selectAllCheckbox.addEventListener('change', function() {
    const checkboxes = document.querySelectorAll('.doc-checkbox');
    checkboxes.forEach(checkbox => {
        checkbox.checked = this.checked;
    });
    updateBulkButtons();
});

// Bulk delete functionality
bulkDeleteBtn.addEventListener('click', function() {
    const selectedDocs = getSelectedDocuments();
    if (selectedDocs.length === 0) {
        addLogMessage('⚠️ Please select documents to delete.');
        return;
    }
    
    // Show custom confirmation modal
    const documentsList = document.getElementById('documentsToDeleteList');
    documentsList.innerHTML = '';
    
    selectedDocs.forEach(docName => {
        const li = document.createElement('li');
        li.className = 'list-group-item';
        li.innerHTML = `<i class="fas fa-file text-primary"></i> ${docName}`;
        documentsList.appendChild(li);
    });
    
    const modal = new bootstrap.Modal(document.getElementById('bulkDeleteModal'));
    modal.show();
});

// Bulk replace functionality
bulkReplaceBtn.addEventListener('click', function() {
    const selectedDocs = getSelectedDocuments();
    if (selectedDocs.length === 0) {
        addLogMessage('⚠️ Please select documents to replace.');
        return;
    }
    
    // Show custom confirmation modal
    const documentsList = document.getElementById('documentsToReplaceList');
    documentsList.innerHTML = '';
    
    selectedDocs.forEach(docName => {
        const li = document.createElement('li');
        li.className = 'list-group-item';
        li.innerHTML = `<i class="fas fa-file text-primary"></i> ${docName}`;
        documentsList.appendChild(li);
    });
    
    const modal = new bootstrap.Modal(document.getElementById('bulkReplaceModal'));
    modal.show();
});

bulkReplaceInput.addEventListener('change', function(e) {
    const selectedDocs = getSelectedDocuments();
    const files = e.target.files;
    
    if (files.length === 0) {
        addLogMessage('⚠️ Please select a file to replace with.');
        return;
    }
    
    if (files.length !== selectedDocs.length) {
        addLogMessage(`⚠️ Please select exactly ${selectedDocs.length} file${selectedDocs.length > 1 ? 's' : ''} to replace the selected documents.`);
        return;
    }
    
    // Replace documents one by one
    let replacedCount = 0;
    let errorCount = 0;
    addLogMessage(`🔄 Starting replacement of ${selectedDocs.length} document${selectedDocs.length > 1 ? 's' : ''}...`);
    
    selectedDocs.forEach((docName, index) => {
        const formData = new FormData();
        formData.append('file', files[index]);
        formData.append('old_filename', docName);
        
        fetch('/replace_document', {
            method: 'POST',
            body: formData
        })
        .then(response => response.json())
        .then(data => {
            if (data.status === 'success') {
                replacedCount++;
                addLogMessage(`🔄 Successfully replaced: ${docName}`);
            } else if (data.status === 'conflict') {
                // Handle filename conflict
                showConflictModal(data.message, data.filename, data.old_filename);
                return; // Stop processing this file
            } else {
                errorCount++;
                console.error(`Error replacing ${docName}: ${data.error}`);
                addLogMessage(`❌ Error replacing ${docName}: ${data.error}`);
            }
            
            // Check if all replaces are complete
            if (replacedCount + errorCount === selectedDocs.length) {
                if (errorCount === 0) {
                    addLogMessage(`🔄 Successfully replaced ${replacedCount} document${replacedCount > 1 ? 's' : ''}`);
                } else {
                    addLogMessage(`⚠️ Replaced ${replacedCount} document${replacedCount > 1 ? 's' : ''}, ${errorCount} failed`);
                }
                
                // Refresh the document list
                setTimeout(() => {
                    loadDocuments();
                }, 1000);
            }
        })
        .catch(error => {
            errorCount++;
            console.error(`Error replacing ${docName}:`, error);
            addLogMessage(`❌ Network error replacing ${docName}: ${error}`);
            
            if (replacedCount + errorCount === selectedDocs.length) {
                addLogMessage(`⚠️ Replaced ${replacedCount} document${replacedCount > 1 ? 's' : ''}, ${errorCount} failed`);
                setTimeout(() => {
                    loadDocuments();
                }, 1000);
            }
        });
    });
    
    bulkReplaceInput.value = '';
});

// Function to disconnect AI and lockout the web instance
function disconnectAndLockout() {
    // Disconnect AI
    aiInitialized = false;
    
    // Clear any ongoing operations
    if (pendingAnimationStop) {
        clearTimeout(pendingAnimationStop);
    }
    
    // Disable all interactive elements
    const interactiveElements = document.querySelectorAll('button, input, textarea, select');
    interactiveElements.forEach(element => {
        element.disabled = true;
    });
    
    // Show lockout message
    const chatArea = document.getElementById('chatMessages');
    if (chatArea) {
        const lockoutMessage = document.createElement('div');
        lockoutMessage.className = 'message ai-message';
        lockoutMessage.innerHTML = '<strong>🔒 SYSTEM LOCKOUT:</strong> Maximum PIN attempts exceeded. This session has been terminated for security reasons.';
        lockoutMessage.style.backgroundColor = '#dc3545';
        lockoutMessage.style.color = 'white';
        lockoutMessage.style.border = '2px solid #c82333';
        chatArea.appendChild(lockoutMessage);
    }
    
    // Disable the upload button specifically
    const addDocBtn = document.getElementById('addDocBtn');
    if (addDocBtn) {
        addDocBtn.disabled = true;
        addDocBtn.classList.remove('btn-primary', 'btn-secondary');
        addDocBtn.classList.add('btn-danger');
        addDocBtn.innerHTML = '<i class="fas fa-lock"></i> LOCKED';
    }
    
    // Add a visual overlay to indicate lockout
    const overlay = document.createElement('div');
    overlay.id = 'lockoutOverlay';
    overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(220, 53, 69, 0.1);
        z-index: 9999;
        pointer-events: none;
    `;
    document.body.appendChild(overlay);
    
    // Update connection status to show "Locked Out"
    const statusIndicator = document.getElementById('statusIndicator');
    const statusText = document.getElementById('statusText');
    if (statusIndicator && statusText) {
        statusIndicator.className = 'status-indicator status-disconnected';
        statusText.textContent = 'Locked Out';
        statusText.style.color = '#dc3545';
        statusText.style.fontWeight = 'bold';
    }
    
    // Log the lockout event
    addLogMessage('🔒 SYSTEM LOCKOUT: Maximum PIN attempts exceeded. Session terminated.');
    
    // Optional: Redirect to a lockout page or show a modal
    setTimeout(() => {
        alert('Session terminated due to security violation.');
    }, 1000);
}

addDocBtn.addEventListener('click', function() {
    if (!uploadButtonUnlocked) {
        // Show pin prompt
        const pin = prompt('Enter security PIN to upload documents:');
        if (pin === null) {
            return; // User cancelled
        }
        if (pin === UPLOAD_PIN) {
            uploadPinCache = pin;
            uploadButtonUnlocked = true;
            this.innerHTML = '<i class="fas fa-plus"></i> Add Documents';
            this.classList.remove('btn-secondary');
            this.classList.add('btn-primary');
        } else {
            wrongPinAttempts++;
            if (wrongPinAttempts >= MAX_PIN_ATTEMPTS) {
                alert('Maximum PIN attempts exceeded. System will now disconnect for security.');
                // Disconnect AI and kill web instance
                disconnectAndLockout();
            } else {
                const remainingAttempts = MAX_PIN_ATTEMPTS - wrongPinAttempts;
                alert(`Incorrect PIN. Access denied. ${remainingAttempts} attempt${remainingAttempts > 1 ? 's' : ''} remaining.`);
            }
        }
    } else {
        // Button is already unlocked, proceed with file selection
        addDocInput.click();
    }
});
addDocInput.addEventListener('change', (e) => {
    const files = e.target.files;
    if (files.length > 0) {
        // Show progress indicator
        const progressId = 'bulk-upload-progress';
        addLogMessage(`📤 Starting bulk upload of ${files.length} document${files.length > 1 ? 's' : ''}...`, progressId);
        
        // Get current topic selection from Docs Management dropdown
        let topicIds = [];
        const topicDropdownMenu = document.getElementById('topicDropdownMenu');
        if (topicDropdownMenu) {
            topicIds = Array.from(topicDropdownMenu.querySelectorAll('.topic-checkbox:checked')).map(cb => cb.value);
        }
        
        // Use the new bulk upload endpoint
        const formData = new FormData();
        for (let i = 0; i < files.length; i++) {
            formData.append('files', files[i]);
        }
        formData.append('topic_ids', JSON.stringify(topicIds));
        
        fetch('/bulk_upload_documents', {
            method: 'POST',
            body: formData
        })
        .then(response => response.json())
        .then(data => {
            if (data.status === 'success') {
                updateLogMessage(progressId, `📤 Bulk upload completed: ${data.successful_count} successful, ${data.failed_count} failed, ${data.conflict_count} conflicts`);
                
                // Log individual results
                data.results.forEach(result => {
                    if (result.status === 'success') {
                        addLogMessage(`✅ ${result.filename}: ${result.message}`);
                    } else if (result.status === 'conflict') {
                        addLogMessage(`⚠️ ${result.filename}: ${result.message}`);
                        showConflictModal(result.message, result.filename);
                    } else {
                        addLogMessage(`❌ ${result.filename}: ${result.error}`);
                    }
                });
                
                // Refresh the document list immediately and then again after a delay
                loadDocuments();
                setTimeout(() => {
                    loadDocuments();
                    // Also update chat topics dropdown in case new topics were created
                    updateChatTopicsDropdown();
                }, 2000);
            } else {
                updateLogMessage(progressId, `❌ Bulk upload failed: ${data.error}`);
            }
        })
        .catch(error => {
            console.error('Bulk upload error:', error);
            updateLogMessage(progressId, `❌ Network error during bulk upload: ${error}`);
        });
    }
});

// --- Document Rename and Conflict Resolution Functions ---

let currentConflictData = null;

function showRenameModal(filename) {
    document.getElementById('renameOldFilename').value = filename;
    document.getElementById('renameNewFilename').value = filename;
    const modal = new bootstrap.Modal(document.getElementById('renameDocModal'));
    modal.show();
}

function showConflictModal(message, filename, oldFilename = null) {
    document.getElementById('conflictMessage').textContent = message;
    document.getElementById('newFilename').value = filename;
    currentConflictData = { filename, oldFilename };
    const modal = new bootstrap.Modal(document.getElementById('filenameConflictModal'));
    modal.show();
}

// Rename document functionality
document.getElementById('confirmRenameBtn').addEventListener('click', function() {
    const oldFilename = document.getElementById('renameOldFilename').value;
    const newFilename = document.getElementById('renameNewFilename').value;
    
    if (!newFilename.trim()) {
        alert('Please enter a new filename');
        return;
    }
    
    // Disable the button to prevent multiple clicks
    const confirmBtn = this;
    const originalText = confirmBtn.innerHTML;
    confirmBtn.disabled = true;
    confirmBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Renaming...';
    
    // Check if new filename already exists
    fetch('/check_filename_conflict', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({ filename: newFilename })
    })
    .then(response => response.json())
    .then(data => {
        if (data.exists) {
            addLogMessage(`⚠️ File "${newFilename}" already exists. Please choose a different name.`);
            confirmBtn.disabled = false;
            confirmBtn.innerHTML = originalText;
            return;
        }
        
        // Proceed with rename
        return fetch('/rename_document', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ 
                old_filename: oldFilename, 
                new_filename: newFilename 
            })
        });
    })
    .then(response => {
        if (response) {
            return response.json();
        }
        return null;
    })
    .then(data => {
        if (data && data.status === 'success') {
            bootstrap.Modal.getInstance(document.getElementById('renameDocModal')).hide();
            addLogMessage(`📝 Document renamed from "${oldFilename}" to "${newFilename}"`);
            // Add a small delay before refreshing to ensure file system operations complete
            setTimeout(() => {
                loadDocuments(); // Refresh the table
            }, 1000);
        } else if (data) {
            addLogMessage(`❌ Error renaming document: ${data.error}`);
        }
    })
    .catch(error => {
        addLogMessage(`❌ Error renaming document: ${error}`);
    })
    .finally(() => {
        // Re-enable the button
        confirmBtn.disabled = false;
        confirmBtn.innerHTML = originalText;
    });
});

// Conflict resolution functionality
document.getElementById('renameConflictBtn').addEventListener('click', function() {
    const newFilename = document.getElementById('newFilename').value;
    
    if (!newFilename.trim()) {
        alert('Please enter a new filename');
        return;
    }
    
    // Disable the button to prevent multiple clicks
    const renameBtn = this;
    const originalText = renameBtn.innerHTML;
    renameBtn.disabled = true;
    renameBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Processing...';
    
    // Check if new filename already exists
    fetch('/check_filename_conflict', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({ filename: newFilename })
    })
    .then(response => response.json())
    .then(data => {
        if (data.exists) {
            addLogMessage(`⚠️ File "${newFilename}" already exists. Please choose a different name.`);
            renameBtn.disabled = false;
            renameBtn.innerHTML = originalText;
            return;
        }
        
        // Continue with the original upload/replace operation using the new filename
        if (currentConflictData && currentConflictData.oldFilename) {
            // This is a replace operation
            continueReplaceWithNewName(newFilename);
        } else {
            // This is an upload operation
            continueUploadWithNewName(newFilename);
        }
    })
    .catch(error => {
        addLogMessage(`❌ Error checking filename: ${error}`);
        renameBtn.disabled = false;
        renameBtn.innerHTML = originalText;
    });
});

document.getElementById('cancelConflictBtn').addEventListener('click', function() {
    bootstrap.Modal.getInstance(document.getElementById('filenameConflictModal')).hide();
    currentConflictData = null;
    // Clear file inputs
    addDocInput.value = '';
    bulkReplaceInput.value = '';
    const replaceInput = document.getElementById('replaceDocInput');
    if (replaceInput) replaceInput.value = '';
});

function continueUploadWithNewName(newFilename) {
    const files = addDocInput.files;
    if (files.length === 0) return;
    
    const file = files[0];
    const formData = new FormData();
    
    // Create a new file with the new name
    const newFile = new File([file], newFilename, { type: file.type });
    formData.append('file', newFile);
    formData.append('topic_ids', JSON.stringify(selectedTopics));
    
    fetch('/upload_document', {
        method: 'POST',
        body: formData
    })
    .then(response => response.json())
    .then(data => {
        bootstrap.Modal.getInstance(document.getElementById('filenameConflictModal')).hide();
        currentConflictData = null;
        
        // Re-enable the conflict resolution button
        const renameBtn = document.getElementById('renameConflictBtn');
        if (renameBtn) {
            renameBtn.disabled = false;
            renameBtn.innerHTML = 'Rename & Continue';
        }
        
        if (data.status === 'success') {
            addLogMessage(`📤 Document "${newFilename}" uploaded successfully`);
            setTimeout(() => {
                loadDocuments();
                // Also update chat topics dropdown in case new topics were created
                updateChatTopicsDropdown();
            }, 1000);
        } else if (data.status === 'conflict') {
            showConflictModal(data.message, data.filename);
        } else {
            addLogMessage(`❌ Error uploading document: ${data.error}`);
        }
    })
    .catch(error => {
        addLogMessage(`❌ Error uploading document: ${error}`);
        // Re-enable the conflict resolution button
        const renameBtn = document.getElementById('renameConflictBtn');
        if (renameBtn) {
            renameBtn.disabled = false;
            renameBtn.innerHTML = 'Rename & Continue';
        }
    });
}

function continueReplaceWithNewName(newFilename) {
    const files = bulkReplaceInput.files;
    if (files.length === 0) return;
    
    const file = files[0];
    const formData = new FormData();
    
    // Create a new file with the new name
    const newFile = new File([file], newFilename, { type: file.type });
    formData.append('file', newFile);
    formData.append('old_filename', currentConflictData.oldFilename);
    formData.append('topic_ids', JSON.stringify(selectedTopics));
    
    fetch('/replace_document', {
        method: 'POST',
        body: formData
    })
    .then(response => response.json())
    .then(data => {
        bootstrap.Modal.getInstance(document.getElementById('filenameConflictModal')).hide();
        currentConflictData = null;
        
        // Re-enable the conflict resolution button
        const renameBtn = document.getElementById('renameConflictBtn');
        if (renameBtn) {
            renameBtn.disabled = false;
            renameBtn.innerHTML = 'Rename & Continue';
        }
        
        if (data.status === 'success') {
            addLogMessage(`🔄 Document "${currentConflictData.oldFilename}" replaced with "${newFilename}"`);
            setTimeout(() => {
                loadDocuments();
                // Also update chat topics dropdown in case new topics were created
                updateChatTopicsDropdown();
            }, 1000);
        } else if (data.status === 'conflict') {
            showConflictModal(data.message, data.filename, data.old_filename);
        } else {
            addLogMessage(`❌ Error replacing document: ${data.error}`);
        }
    })
    .catch(error => {
        addLogMessage(`❌ Error replacing document: ${error}`);
        // Re-enable the conflict resolution button
        const renameBtn = document.getElementById('renameConflictBtn');
        if (renameBtn) {
            renameBtn.disabled = false;
            renameBtn.innerHTML = 'Rename & Continue';
        }
    });
}

// --- Topic Management Functions ---

let currentTopic = 'all';
window.selectedTopics = window.selectedTopics || [];
let topics = [];

function loadTopics(callback) {
    fetch('/get_topics')
    .then(response => response.json())
    .then(data => {
        if (data.topics) {
            topics = data.topics;
            updateTopicDropdown();
            if (callback) callback();
        } else {
            if (callback) callback();
        }
    })
    .catch(error => {
        console.error('Error loading topics:', error);
        if (callback) callback();
    });
}

function updateTopicDropdown() {
    const dropdownMenu = document.getElementById('topicDropdownMenu');
    const topicCheckboxes = document.getElementById('topicCheckboxes');
    
    // Clear existing topic checkboxes
    topicCheckboxes.innerHTML = '';
    
    // Add topic checkboxes
    topics.forEach(topic => {
        const div = document.createElement('div');
        div.className = 'form-check';
        div.innerHTML = `
            <input class="form-check-input topic-checkbox" type="checkbox" value="${topic.id}" id="topic_${topic.id}">
            <label class="form-check-label" for="topic_${topic.id}">
                📂 ${topic.name}
            </label>
        `;
        topicCheckboxes.appendChild(div);
    });
    
    // Add event listeners to checkboxes
    const checkboxes = topicCheckboxes.querySelectorAll('.topic-checkbox');
    console.log('Adding event listeners to', checkboxes.length, 'checkboxes');
         checkboxes.forEach(checkbox => {
         // Remove any existing event listeners
         checkbox.removeEventListener('change', updateSelectedTopics);
         // Add new event listener
         checkbox.addEventListener('change', function(e) {
             console.log('Checkbox changed:', checkbox.value, checkbox.checked);
             e.preventDefault();
             e.stopPropagation();
             // Force immediate update
             updateSelectedTopics();
         });
     });
     
     // Update delete button state
     updateDeleteTopicsButton();
 }

function updateSelectedTopics() {
    console.log('updateSelectedTopics called');
    const checkboxes = document.querySelectorAll('.topic-checkbox:checked');
    window.selectedTopics = Array.from(checkboxes).map(cb => cb.value);
    
    console.log('Selected topics:', window.selectedTopics);
    
    // Update dropdown button text
    if (window.selectedTopics.length === 0) {
        document.getElementById('currentTopicName').textContent = 'All Topics';
        currentTopic = 'all';
    } else if (window.selectedTopics.length === 1) {
        const topic = topics.find(t => t.id == window.selectedTopics[0]);
        document.getElementById('currentTopicName').textContent = topic ? topic.name : 'Unknown Topic';
        currentTopic = window.selectedTopics[0];
    } else {
        document.getElementById('currentTopicName').textContent = `${window.selectedTopics.length} Topics Selected`;
        currentTopic = 'multiple';
    }
    
         addLogMessage(`📂 Selected topics: ${window.selectedTopics.length > 0 ? window.selectedTopics.map(id => topics.find(t => t.id == id)?.name).join(', ') : 'All Topics'}`);
     
     // Update delete button state
     updateDeleteTopicsButton();
     
     // Force immediate reload of documents
     console.log('Calling loadDocuments with topic:', currentTopic);
     loadDocuments();
 }

function switchTopic(topicId) {
    currentTopic = topicId;
    window.selectedTopics = topicId === 'all' ? [] : [topicId];
    
    // Update the document management topic dropdown checkboxes
    updateDocumentManagementTopicSelection();
    
    // Get topic name, with fallback for when topics are still loading
    let topicName = 'All Topics';
    if (topicId !== 'all') {
        const topic = topics.find(t => t.id == topicId);
        topicName = topic ? topic.name : `Topic ${topicId}`;
    }
    
    document.getElementById('currentTopicName').textContent = topicName;
    
    // Load documents for this topic
    loadDocuments();
    
    addLogMessage(`📂 Switched to topic: ${topicName}`);
}

// Update loadDocuments to filter by topic
function loadDocuments() {
    const cacheBuster = Date.now();
    console.log('Loading documents for topic:', currentTopic, 'selectedTopics:', window.selectedTopics);
    
    let url = `/get_documents?cb=${cacheBuster}&topic=${currentTopic}`;
    if (currentTopic === 'multiple' && window.selectedTopics.length > 0) {
        url += `&selected_topics=${JSON.stringify(window.selectedTopics)}`;
    }
    
    console.log('Fetching URL:', url);
    
    // Show loading state
    docsTableBody.innerHTML = '<tr><td colspan="6" class="text-center text-muted">Loading documents...</td></tr>';
    
    fetch(url)
        .then(response => response.json())
        .then(data => {
            console.log('Documents response:', data);
            if (data.documents) {
                // Backend now handles all filtering, just use the returned documents
                docsList = data.documents;
                console.log('Documents loaded:', docsList.length, docsList);
                renderDocsTable();
                updateBulkButtons();
            } else {
                console.error('Error loading documents:', data.error);
                docsTableBody.innerHTML = '<tr><td colspan="6" class="text-center text-muted">Error loading documents</td></tr>';
            }
        })
        .catch(error => {
            console.error('Error fetching documents:', error);
            docsTableBody.innerHTML = '<tr><td colspan="6" class="text-center text-muted">Error loading documents</td></tr>';
        });
}

// Topic dropdown event listeners
document.addEventListener('click', function(e) {
    if (e.target.matches('[data-topic]')) {
        e.preventDefault();
        const topicId = e.target.getAttribute('data-topic');
        switchTopic(topicId);
    }
});

// Create topic button
document.getElementById('createTopicBtn').addEventListener('click', function(e) {
    e.preventDefault();
    const modal = new bootstrap.Modal(document.getElementById('createTopicModal'));
    modal.show();
});

 // Create topic functionality
 document.getElementById('confirmCreateTopicBtn').addEventListener('click', function() {
     const topicName = document.getElementById('topicName').value.trim();
     const topicDescription = document.getElementById('topicDescription').value.trim();
     
     if (!topicName) {
         addLogMessage('⚠️ Please enter a topic name');
         return;
     }
     
     fetch('/create_topic', {
         method: 'POST',
         headers: {
             'Content-Type': 'application/json',
         },
         body: JSON.stringify({
             name: topicName,
             description: topicDescription
         })
     })
     .then(response => response.json())
     .then(data => {
         if (data.status === 'success') {
             bootstrap.Modal.getInstance(document.getElementById('createTopicModal')).hide();
             addLogMessage(`📂 Created new topic: "${topicName}"`);
             
             // Clear form
             document.getElementById('topicName').value = '';
             document.getElementById('topicDescription').value = '';
             
             // Reload topics and switch to the new topic
             loadTopics(() => {
                 console.log('[DEBUG] Topics reloaded, updating dropdowns...');
                 
                 // Update the chat topics dropdown
                 updateChatTopicsDropdown();
                 
                 // Update the document management topic dropdown
                 updateDocumentManagementTopics();
                 
                 console.log('[DEBUG] Dropdowns updated, switching to topic...');
                 
                 // Switch to the new topic (with longer delay to ensure dropdown is ready)
                 setTimeout(() => {
                     console.log(`[DEBUG] Switching to topic ${data.topic_id}...`);
                     switchTopic(data.topic_id);
                     
                     // Force update the dropdown selection after switching
                     setTimeout(() => {
                         console.log('[DEBUG] Forcing dropdown selection update...');
                         updateDocumentManagementTopicSelection();
                         
                         // Force select the new topic in the dropdown
                         forceSelectTopicInDropdown(data.topic_id);
                     }, 300);
                 }, 300);
             });
         } else {
             addLogMessage(`❌ Error creating topic: ${data.error}`);
         }
     })
     .catch(error => {
         addLogMessage(`❌ Error creating topic: ${error}`);
     });
 });
 
 // Delete topics functionality
 document.getElementById('deleteTopicsBtn').addEventListener('click', function() {
     if (selectedTopics.length === 0) {
         addLogMessage('⚠️ Please select topics to delete');
         return;
     }
     
     // Show custom confirmation modal
     const topicNames = selectedTopics.map(id => topics.find(t => t.id == id)?.name).filter(Boolean);
     const topicsList = document.getElementById('topicsToDeleteList');
     topicsList.innerHTML = '';
     
     topicNames.forEach(name => {
         const li = document.createElement('li');
         li.className = 'list-group-item';
         li.innerHTML = `<i class="fas fa-tag text-primary"></i> ${name}`;
         topicsList.appendChild(li);
     });
     
     const modal = new bootstrap.Modal(document.getElementById('deleteTopicsModal'));
     modal.show();
 });
 
 function updateDeleteTopicsButton() {
     const deleteBtn = document.getElementById('deleteTopicsBtn');
     if (deleteBtn) {
         deleteBtn.disabled = selectedTopics.length === 0;
     }
 }
 
 // Confirm delete topics functionality
 document.getElementById('confirmDeleteTopicsBtn').addEventListener('click', function() {
     // Disable the button to prevent multiple clicks
     const confirmBtn = this;
     const originalText = confirmBtn.innerHTML;
     confirmBtn.disabled = true;
     confirmBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Deleting...';
     
     fetch('/delete_topics', {
         method: 'POST',
         headers: {
             'Content-Type': 'application/json',
         },
         body: JSON.stringify({
             topic_ids: selectedTopics
         })
     })
     .then(response => response.json())
     .then(data => {
         if (data.status === 'success') {
             addLogMessage(`🗑️ ${data.message}`);
             
             // Clear selected topics and reset to All Topics
             selectedTopics = [];
             currentTopic = 'all';
             document.getElementById('currentTopicName').textContent = 'All Topics';
             
             // Close modal
             bootstrap.Modal.getInstance(document.getElementById('deleteTopicsModal')).hide();
             
             // Reload topics, then load all documents after dropdown is rebuilt
             loadTopics(() => {
                 // Update the chat topics dropdown
                 updateChatTopicsDropdown();
                 
                 // Update the document management topic dropdown
                 updateDocumentManagementTopics();
                 
                          // Check if the deleted topic was the current chat topic and switch to All Topics if needed
         checkAndSwitchChatTopicIfDeleted();
         
                  // Force switch to All Topics if we were on a deleted topic
         forceSwitchToAllTopicsIfNeeded();
         
         // Also directly check and fix chat topic selection
         fixChatTopicSelectionAfterDeletion();
         
         // Load documents
         loadDocuments();
             });
         } else {
             addLogMessage(`❌ Error deleting topics: ${data.error}`);
         }
     })
     .catch(error => {
         addLogMessage(`❌ Error deleting topics: ${error}`);
     })
     .finally(() => {
         // Re-enable the button
         confirmBtn.disabled = false;
         confirmBtn.innerHTML = originalText;
     });
 });

// --- End Topic Management Functions ---

// --- End Document Rename and Conflict Resolution Functions ---

// Load documents and topics when page loads
loadDocuments();
loadTopics();

// Ensure topic selection is synchronized after everything loads
document.addEventListener('DOMContentLoaded', function() {
    // Wait a bit for topics to load, then sync
    setTimeout(() => {
        if (topics && topics.length > 0) {
            syncTopicDropdownWithCurrentView();
            
            // Also check if any deleted topics need chat switching
            checkAndSwitchChatTopicIfDeleted();
        }
    }, 1000);
});

 // Initialize topic checkboxes after topics are loaded
 setTimeout(() => {
     console.log('Initializing topic checkboxes...');
     updateTopicDropdown();
     
     // Set initial state
     selectedTopics = [];
     currentTopic = 'all';
     document.getElementById('currentTopicName').textContent = 'All Topics';
     
     // Initialize delete button state
     updateDeleteTopicsButton();
     
     // Ensure the dropdown reflects the current selection
     updateDocumentManagementTopicSelection();
 }, 500);
 // Confirm bulk delete functionality
 document.getElementById('confirmBulkDeleteBtn').addEventListener('click', function() {
     const selectedDocs = getSelectedDocuments();
     
     // Close modal
     bootstrap.Modal.getInstance(document.getElementById('bulkDeleteModal')).hide();
     
     // Show progress indicator
     const progressId = 'bulk-delete-progress';
     addLogMessage(`🗑️ Starting bulk deletion of ${selectedDocs.length} document${selectedDocs.length > 1 ? 's' : ''}...`, progressId);
     
     // Use the new bulk delete endpoint
     fetch('/bulk_delete_documents', {
         method: 'POST',
         headers: {
             'Content-Type': 'application/json',
         },
         body: JSON.stringify({filenames: selectedDocs})
     })
     .then(response => response.json())
     .then(data => {
         if (data.status === 'success') {
             updateLogMessage(progressId, `🗑️ Bulk delete completed: ${data.successful_count} successful, ${data.failed_count} failed`);
             
             // Log individual results
             data.results.forEach(result => {
                 if (result.status === 'success') {
                     addLogMessage(`✅ ${result.filename}: ${result.message}`);
                 } else {
                     addLogMessage(`❌ ${result.filename}: ${result.error}`);
                 }
             });
             
             // Refresh the document list immediately and then again after a delay
             loadDocuments();
             setTimeout(() => {
                 loadDocuments();
             }, 2000);
         } else {
             updateLogMessage(progressId, `❌ Bulk delete failed: ${data.error}`);
         }
     })
     .catch(error => {
         console.error('Bulk delete error:', error);
         updateLogMessage(progressId, `❌ Network error during bulk delete: ${error}`);
     });
 });
 
 // Confirm bulk replace functionality
 document.getElementById('confirmBulkReplaceBtn').addEventListener('click', function() {
     // Close modal
     bootstrap.Modal.getInstance(document.getElementById('bulkReplaceModal')).hide();
     
     // Trigger file input for replacement files
     const bulkReplaceInput = document.getElementById('bulkReplaceInput');
     bulkReplaceInput.click();
 });
 
 // --- End Document Management UI Logic ---

// --- Topic Editing Functions ---
function showEditTopicsModal(filename, currentTags) {
    // Populate the modal with current document info
    document.getElementById('editTopicsDocName').textContent = filename;
    
    // Get all available topics
    const topicCheckboxes = document.getElementById('editTopicsCheckboxes');
    topicCheckboxes.innerHTML = '';
    
    // Ensure topics are loaded
    if (!topics || topics.length === 0) {
        // Load topics if not already loaded
        loadTopics(() => {
            populateTopicCheckboxes(currentTags);
        });
    } else {
        populateTopicCheckboxes(currentTags);
    }
    
    // Show the modal
    const modal = new bootstrap.Modal(document.getElementById('editTopicsModal'));
    modal.show();
}

function populateTopicCheckboxes(currentTags) {
    const topicCheckboxes = document.getElementById('editTopicsCheckboxes');
    topicCheckboxes.innerHTML = '';
    
    // Add checkboxes for each topic
    topics.forEach(topic => {
        const div = document.createElement('div');
        div.className = 'form-check';
        const isChecked = currentTags.includes(topic.name) ? 'checked' : '';
        div.innerHTML = `
            <input class="form-check-input edit-topic-checkbox" type="checkbox" value="${topic.id}" id="edit_topic_${topic.id}" ${isChecked}>
            <label class="form-check-label" for="edit_topic_${topic.id}">
                📂 ${topic.name}
            </label>
        `;
        topicCheckboxes.appendChild(div);
    });
}

// Add event listener for save button
document.addEventListener('DOMContentLoaded', function() {
    const saveTopicsBtn = document.getElementById('saveTopicsBtn');
    if (saveTopicsBtn) {
        saveTopicsBtn.addEventListener('click', function() {
            saveDocumentTopics();
        });
    }
});

function saveDocumentTopics() {
    const filename = document.getElementById('editTopicsDocName').textContent;
    const selectedTopics = Array.from(document.querySelectorAll('.edit-topic-checkbox:checked')).map(cb => cb.value);
    
    // Show loading state
    const saveBtn = document.getElementById('saveTopicsBtn');
    const originalText = saveBtn.innerHTML;
    saveBtn.disabled = true;
    saveBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Saving...';
    
    // Send update request to backend
    fetch('/update_document_topics', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            filename: filename,
            topic_ids: selectedTopics
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.status === 'success') {
            // Close modal
            bootstrap.Modal.getInstance(document.getElementById('editTopicsModal')).hide();
            
            // Show success message
            addLogMessage(`✅ Topics updated for "${filename}"`);
            
            // Update the specific document row in the table immediately
            updateDocumentRowTopics(filename, data.updated_topics || []);
            
            // Refresh the documents table to show updated topics
            loadDocuments();
            
            // Update the chat topics dropdown to reflect changes
            updateChatTopicsDropdown();
        } else {
            addLogMessage(`❌ Error updating topics: ${data.error}`);
        }
    })
    .catch(error => {
        addLogMessage(`❌ Error updating topics: ${error.message}`);
    })
    .finally(() => {
        // Restore button state
        saveBtn.disabled = false;
        saveBtn.innerHTML = originalText;
    });
}

// --- End Topic Editing Functions ---

// --- Real-time Updates Functions ---
function updateChatTopicsDropdown() {
    // Reload topics from the server
    loadTopics(() => {
        // Update the chat topics dropdown menu
        const menu = document.getElementById('chatTopicsDropdownMenu');
        if (!menu) return;
        
        // Clear existing menu items
        menu.innerHTML = '';
        
        // Add All Topics option
        const allLi = document.createElement('li');
        allLi.innerHTML = `<div class="form-check"><input class="form-check-input" type="checkbox" value="all" id="chatTopic_all"><label class="form-check-label" for="chatTopic_all">All Topics</label></div>`;
        menu.appendChild(allLi);
        
        // Add other topics
        (topics || []).forEach(topic => {
            const li = document.createElement('li');
            li.innerHTML = `<div class="form-check"><input class="form-check-input" type="checkbox" value="${topic.id}" id="chatTopic_${topic.id}"><label class="form-check-label" for="chatTopic_${topic.id}">${topic.name}</label></div>`;
            menu.appendChild(li);
        });
        
        // Restore previously selected topics if possible
        restoreChatTopicSelection();
        
        // Check if any selected topics were deleted and switch to All Topics if needed
        checkAndSwitchChatTopicIfDeleted();
        
        // Update the chat input state
        updateChatInputState();
    });
}

function restoreChatTopicSelection() {
    // Try to restore the previously selected topics
    const menu = document.getElementById('chatTopicsDropdownMenu');
    if (!menu) return;
    
    // Get current selection from the button text
    const btn = document.getElementById('chatTopicsDropdownBtn');
    if (!btn) return;
    
    const currentSelection = btn.textContent.trim();
    
    if (currentSelection === 'All Topics') {
        // Check the 'all' checkbox
        const allCheckbox = menu.querySelector('#chatTopic_all');
        if (allCheckbox) allCheckbox.checked = true;
            } else if (currentSelection !== 'All Topics') {
        // Try to restore specific topic selections
        const topicNames = currentSelection.split(', ');
        topicNames.forEach(topicName => {
            const topic = topics.find(t => t.name === topicName);
            if (topic) {
                const checkbox = menu.querySelector(`#chatTopic_${topic.id}`);
                if (checkbox) checkbox.checked = true;
            }
        });
    }
}

// --- End Real-time Updates Functions ---

// --- Immediate UI Updates ---
function updateDocumentRowTopics(filename, updatedTopics) {
    // Find the document row in the table
    const topicCell = document.querySelector(`.editable-topics[data-filename="${filename}"]`);
    if (!topicCell) return;
    
    // Update the data-tags attribute
    topicCell.setAttribute('data-tags', JSON.stringify(updatedTopics));
    
    // Update the visual display
    const topicsContainer = topicCell.querySelector('.topics-container');
    if (topicsContainer) {
        const tagsHtml = updatedTopics.length > 0 ? 
            updatedTopics.map(tag => `<span class="badge bg-primary me-1">${tag}</span>`).join('') : 
            '<span class="text-muted">No tags</span>';
        
        topicsContainer.innerHTML = tagsHtml;
    }
}

// --- End Immediate UI Updates ---

// --- Document Management Topic Updates ---
function updateDocumentManagementTopics() {
    // Update the document management topic dropdown
    const topicDropdownMenu = document.getElementById('topicDropdownMenu');
    if (!topicDropdownMenu) return;
    
    // Find the topicCheckboxes container specifically
    const topicCheckboxesContainer = document.getElementById('topicCheckboxes');
    if (!topicCheckboxesContainer) return;
    
    // Clear only the topic checkboxes container, not the entire dropdown
    topicCheckboxesContainer.innerHTML = '';
    
    // Add updated topic checkboxes to the container
    (topics || []).forEach(topic => {
        const div = document.createElement('div');
        div.className = 'form-check';
        div.innerHTML = `
            <input class="form-check-input topic-checkbox" type="checkbox" value="${topic.id}" id="doc_topic_${topic.id}">
            <label class="form-check-label" for="doc_topic_${topic.id}">
                📂 ${topic.name}
            </label>
        `;
        topicCheckboxesContainer.appendChild(div);
    });
    
    // Re-attach event listeners
    attachDocumentManagementTopicListeners();
    
    // Restore the current selection state
    updateDocumentManagementTopicSelection();
}

function attachDocumentManagementTopicListeners() {
    const topicDropdownMenu = document.getElementById('topicDropdownMenu');
    if (!topicDropdownMenu) return;
    
    // Add event listeners to new topic checkboxes
    const checkboxes = topicDropdownMenu.querySelectorAll('.topic-checkbox');
    checkboxes.forEach(checkbox => {
        checkbox.addEventListener('change', function() {
            // Update the selected topics
            updateSelectedTopics();
            
            // Update the current topic state to match the selection
            if (selectedTopics.length === 0) {
                currentTopic = 'all';
                document.getElementById('currentTopicName').textContent = 'All Topics';
            } else if (selectedTopics.length === 1) {
                currentTopic = selectedTopics[0];
                const topic = topics.find(t => t.id == selectedTopics[0]);
                if (topic) {
                    document.getElementById('currentTopicName').textContent = topic.name;
                }
            } else {
                currentTopic = 'multiple';
                const topicNames = selectedTopics.map(id => topics.find(t => t.id == id)?.name).filter(Boolean);
                document.getElementById('currentTopicName').textContent = topicNames.join(', ');
            }
            
            // Load documents for the new selection
            loadDocuments();
        });
    });
}

// --- End Document Management Topic Updates ---

// --- Topic Selection Synchronization ---
function updateDocumentManagementTopicSelection() {
    // Update the document management topic dropdown to reflect current selection
    const topicDropdownMenu = document.getElementById('topicDropdownMenu');
    if (!topicDropdownMenu) return;
    
    // Get all topic checkboxes in the document management dropdown
    const checkboxes = topicDropdownMenu.querySelectorAll('.topic-checkbox');
    
    checkboxes.forEach(checkbox => {
        const topicId = checkbox.value;
        
        if (currentTopic === 'all') {
            // If "All Topics" is selected, uncheck all specific topics
            checkbox.checked = false;
        } else if (currentTopic === 'multiple') {
            // If multiple topics are selected, check the ones in selectedTopics
            checkbox.checked = selectedTopics.includes(topicId);
        } else {
            // If a single topic is selected, check only that one
            checkbox.checked = (topicId === currentTopic);
        }
    });
    
    // Also update the delete button state
    updateDeleteTopicsButton();
}

// Function to sync the current view with the dropdown selection
function syncTopicDropdownWithCurrentView() {
    // If we're viewing a specific topic, make sure it's selected in the dropdown
    if (currentTopic !== 'all' && currentTopic !== 'multiple') {
        // Find the topic name for the current topic ID
        const topic = topics.find(t => t.id == currentTopic);
        if (topic) {
            // Update the button text to show the current topic
            document.getElementById('currentTopicName').textContent = topic.name;
            
            // Update the dropdown selection
            updateDocumentManagementTopicSelection();
        }
    }
}

// --- End Topic Selection Synchronization ---

// --- Chat Topic Management ---
function checkAndSwitchChatTopicIfDeleted() {
    console.log('[DEBUG] Checking if deleted topics need chat switching...');
    
    // Get the current chat topic selection
    const chatTopicsMenu = document.getElementById('chatTopicsDropdownMenu');
    if (!chatTopicsMenu) {
        console.log('[DEBUG] Chat topics menu not found!');
        return;
    }
    
    // Check if any of the currently selected chat topics still exist
    const checkedTopics = chatTopicsMenu.querySelectorAll('.form-check-input:checked');
    let hasValidTopics = false;
    let deletedTopics = [];
    
    console.log(`[DEBUG] Checking ${checkedTopics.length} selected chat topics...`);
    console.log(`[DEBUG] Available topics:`, topics.map(t => ({id: t.id, name: t.name})));
    console.log(`[DEBUG] Current chat session key: ${currentChatSessionKey}`);
    
    // Also check the currentChatSessionKey to see what topic we're actually on
    if (currentChatSessionKey && currentChatSessionKey.startsWith('topics:')) {
        const sessionTopicId = currentChatSessionKey.split(':')[1];
        console.log(`[DEBUG] Current chat session topic ID: ${sessionTopicId}`);
        
        if (sessionTopicId !== 'all') {
            const sessionTopicExists = topics.some(t => t.id == sessionTopicId);
            console.log(`[DEBUG] Session topic ${sessionTopicId} exists: ${sessionTopicExists}`);
            
            if (!sessionTopicExists) {
                deletedTopics.push(sessionTopicId);
                console.log(`[DEBUG] Session topic ${sessionTopicId} was deleted (from session key)`);
            }
        }
    }
    
    checkedTopics.forEach(checkbox => {
        const topicValue = checkbox.value;
        console.log(`[DEBUG] Checking topic value: ${topicValue}`);
        
        if (topicValue === 'all') {
            hasValidTopics = true;
            console.log(`[DEBUG] Topic ${topicValue} is special (all)`);
        } else {
            // Check if this topic still exists in the topics array
            const topicExists = topics.some(t => t.id == topicValue);
            console.log(`[DEBUG] Topic ${topicValue} exists: ${topicExists}`);
            
            if (topicExists) {
                hasValidTopics = true;
            } else {
                deletedTopics.push(topicValue);
                console.log(`[DEBUG] Topic ${topicValue} was deleted`);
            }
        }
    });
    
    console.log(`[DEBUG] Deleted topics found: ${deletedTopics.length}`, deletedTopics);
    
    // If we have deleted topics, clear their chat history and switch to All Topics
    if (deletedTopics.length > 0) {
        console.log(`[DEBUG] Clearing chat history for deleted topics: ${deletedTopics}`);
        
        // Clear chat history for deleted topics
        deletedTopics.forEach(topicId => {
            const sessionKey = `topics:${topicId}`;
            if (chatHistories[sessionKey]) {
                delete chatHistories[sessionKey];
                console.log(`[DEBUG] Deleted chat history for session: ${sessionKey}`);
            }
        });
        
        // Uncheck all topics
        checkedTopics.forEach(checkbox => {
            checkbox.checked = false;
        });
        
        // Check "All Topics"
        const allTopicsCheckbox = chatTopicsMenu.querySelector('#chatTopic_all');
        if (allTopicsCheckbox) {
            allTopicsCheckbox.checked = true;
        }
        
        // Update the chat input state
        updateChatInputState();
        
        // Update the chat session
        currentChatSessionKey = 'topics:all';
        
        // Display the updated chat history
        displayChatHistory(currentChatSessionKey);
        
        // Force refresh the chat area to ensure it shows the new state
        forceRefreshChatDisplay();
        
        addLogMessage('📂 Switched to All Topics (previous topic was deleted)');
        
        console.log('[DEBUG] Successfully switched to All Topics');
    }
}

// --- End Chat Topic Management ---

// --- Force Topic Selection ---
function forceSelectTopicInDropdown(topicId) {
    console.log(`[DEBUG] Force selecting topic ${topicId} in dropdown`);
    
    // Try multiple selectors to find the checkbox
    const selectors = [
        `#doc_topic_${topicId}`,
        `input[value="${topicId}"].topic-checkbox`,
        `input[value="${topicId}"]`
    ];
    
    let checkbox = null;
    for (const selector of selectors) {
        checkbox = document.querySelector(selector);
        if (checkbox) {
            console.log(`[DEBUG] Found checkbox with selector: ${selector}`);
            break;
        }
    }
    
    if (checkbox) {
        // Uncheck all other topics first
        const allCheckboxes = document.querySelectorAll('.topic-checkbox');
        allCheckboxes.forEach(cb => {
            cb.checked = false;
        });
        
        // Check the new topic
        checkbox.checked = true;
        console.log(`[DEBUG] Successfully checked topic ${topicId}`);
        
        // Update the selected topics array
        selectedTopics = [topicId];
        
        // Update the button text
        const topic = topics.find(t => t.id == topicId);
        if (topic) {
            document.getElementById('currentTopicName').textContent = topic.name;
        }
        
        // Update the delete button state
        updateDeleteTopicsButton();
        
        // Trigger change event to update the UI
        checkbox.dispatchEvent(new Event('change'));
    } else {
        console.log(`[DEBUG] Could not find checkbox for topic ${topicId}`);
        console.log(`[DEBUG] Available checkboxes:`, document.querySelectorAll('.topic-checkbox'));
    }
}

// --- End Force Topic Selection ---

// --- Chat Display Management ---
function forceRefreshChatDisplay() {
    console.log('[DEBUG] Force refreshing chat display...');
    
    // Clear the chat messages area
    const chatMessages = document.getElementById('chatMessages');
    if (chatMessages) {
        chatMessages.innerHTML = '';
    }
    
    // Force a complete refresh of the chat display
    if (currentChatSessionKey) {
        displayChatHistory(currentChatSessionKey);
    }
    
    // Update the chat input state
    updateChatInputState();
    
    console.log('[DEBUG] Chat display refreshed');
}

// --- End Chat Display Management ---

// --- Force Topic Switching ---
function forceSwitchToAllTopicsIfNeeded() {
    console.log('[DEBUG] Force switching to All Topics if needed...');
    
    // Check if currentChatSessionKey is on a deleted topic
    if (currentChatSessionKey && currentChatSessionKey.startsWith('topics:')) {
        const sessionTopicId = currentChatSessionKey.split(':')[1];
        
        if (sessionTopicId !== 'all') {
            const topicExists = topics.some(t => t.id == sessionTopicId);
            
            if (!topicExists) {
                console.log(`[DEBUG] Force switching from deleted topic ${sessionTopicId} to All Topics`);
                
                // Force uncheck all chat topic checkboxes
                const chatTopicsMenu = document.getElementById('chatTopicsDropdownMenu');
                if (chatTopicsMenu) {
                    const allChatCheckboxes = chatTopicsMenu.querySelectorAll('.form-check-input');
                    allChatCheckboxes.forEach(cb => {
                        cb.checked = false;
                    });
                    
                    // Check "All Topics"
                    const allTopicsCheckbox = chatTopicsMenu.querySelector('#chatTopic_all');
                    if (allTopicsCheckbox) {
                        allTopicsCheckbox.checked = true;
                    }
                }
                
                // Update the chat session
                currentChatSessionKey = 'topics:all';
                
                // Clear the chat display
                const chatMessages = document.getElementById('chatMessages');
                if (chatMessages) {
                    chatMessages.innerHTML = '';
                }
                
                // Display All Topics chat history
                displayChatHistory(currentChatSessionKey);
                
                // Update chat input state
                updateChatInputState();
                
                console.log('[DEBUG] Successfully forced switch to All Topics');
            }
        }
    }
}

// --- End Force Topic Switching ---

// --- Fix Chat Topic Selection ---
function fixChatTopicSelectionAfterDeletion() {
    console.log('[DEBUG] Fixing chat topic selection after deletion...');
    
    // Get all chat topic checkboxes
    const chatTopicsMenu = document.getElementById('chatTopicsDropdownMenu');
    if (!chatTopicsMenu) {
        console.log('[DEBUG] Chat topics menu not found for fixing');
        return;
    }
    
    const chatCheckboxes = chatTopicsMenu.querySelectorAll('.form-check-input');
    let hasValidSelection = false;
    let needsFix = false;
    
    // Check each checkbox
    chatCheckboxes.forEach(checkbox => {
        const topicValue = checkbox.value;
        
        if (checkbox.checked) {
            if (topicValue === 'all') {
                hasValidSelection = true;
            } else {
                // Check if this topic still exists
                const topicExists = topics.some(t => t.id == topicValue);
                if (!topicExists) {
                    console.log(`[DEBUG] Found checked deleted topic: ${topicValue}, unchecking`);
                    checkbox.checked = false;
                    needsFix = true;
                } else {
                    hasValidSelection = true;
                }
            }
        }
    });
    
    // If no valid selection or we need to fix, switch to All Topics
    if (!hasValidSelection || needsFix) {
        console.log('[DEBUG] No valid selection or need fix, switching to All Topics');
        
        // Uncheck all
        chatCheckboxes.forEach(cb => {
            cb.checked = false;
        });
        
        // Check All Topics
        const allTopicsCheckbox = chatTopicsMenu.querySelector('#chatTopic_all');
        if (allTopicsCheckbox) {
            allTopicsCheckbox.checked = true;
            console.log('[DEBUG] Checked All Topics checkbox');
        }
        
        // Update session
        currentChatSessionKey = 'topics:all';
        
        // Clear and refresh chat
        const chatMessages = document.getElementById('chatMessages');
        if (chatMessages) {
            chatMessages.innerHTML = '';
        }
        
        displayChatHistory(currentChatSessionKey);
        updateChatInputState();
        
        console.log('[DEBUG] Successfully fixed chat topic selection');
    }
}

// --- End Fix Chat Topic Selection ---

// Comment out delete animation usage
// const stopAnimation = showDeleteAnimation();

function updateSortArrows() {
    document.querySelectorAll('.sort-arrow').forEach(arrow => {
        const col = arrow.getAttribute('data-col');
        const idx = sortLevels.findIndex(s => s.column === col);
        if (idx === 0) {
            arrow.innerHTML = sortLevels[0].direction === 'asc' ? '▲' : '▼';
        } else if (idx > 0) {
            // Arrow plus clickable superscript number
            arrow.innerHTML = (sortLevels[idx].direction === 'asc' ? '▲' : '▼') + `<sup style="cursor:pointer;">${String.fromCharCode(0x2460 + idx - 1)}</sup>`;
        } else {
            arrow.textContent = '▲▼';
        }
    });
}

// Patch renderDocsTable to call updateSortArrows after rendering
const originalRenderDocsTable = renderDocsTable;
renderDocsTable = function() {
    // Always sort docsList using current sortLevels before rendering
    docsList.sort((a, b) => {
        for (let { column, direction } of sortLevels) {
            let av = a[column], bv = b[column];
            if (column === 'topics') {
                av = (a.tags || []).join(',');
                bv = (b.tags || []).join(',');
            }
            if (column === 'name') {
                av = av ? av.toLowerCase() : '';
                bv = bv ? bv.toLowerCase() : '';
            }
            if (av < bv) return direction === 'asc' ? -1 : 1;
            if (av > bv) return direction === 'asc' ? 1 : -1;
        }
        return 0;
    });
    originalRenderDocsTable();
    updateSortArrows();
};

// Add popup menu for multi-level sort order selection
function showSortOrderPopup(arrow, col, idx) {
    // Remove any existing popup
    const existing = document.getElementById('sortOrderPopup');
    if (existing) existing.remove();
    const popup = document.createElement('div');
    popup.id = 'sortOrderPopup';
    popup.style.position = 'absolute';
    popup.style.background = '#fff';
    popup.style.border = '1px solid #ccc';
    popup.style.borderRadius = '6px';
    popup.style.boxShadow = '0 2px 8px rgba(0,0,0,0.15)';
    popup.style.padding = '4px 8px';
    popup.style.zIndex = 10000;
    popup.style.display = 'flex';
    popup.style.gap = '6px';
    // Get arrow position
    const rect = arrow.getBoundingClientRect();
    popup.style.left = `${rect.left + window.scrollX}px`;
    popup.style.top = `${rect.top + window.scrollY - 32}px`;
    // Add ⓪ for main sorter
    const zero = document.createElement('span');
    zero.textContent = '⓪';
    zero.style.cursor = 'pointer';
    zero.style.fontSize = '1.2em';
    zero.style.padding = '0 4px';
    if (idx === 0) {
        zero.style.fontWeight = 'bold';
        zero.style.color = '#B0E0E6';
    }
    zero.title = 'Make main sorter';
    zero.addEventListener('click', function(e) {
        e.stopPropagation();
        const currentIdx = sortLevels.findIndex(s => s.column === col);
        if (currentIdx !== -1) {
            const [item] = sortLevels.splice(currentIdx, 1);
            sortLevels.unshift(item);
            renderDocsTable();
            updateSortArrows();
        }
        popup.remove();
    });
    popup.appendChild(zero);
    // Add numbers 1 to N
    for (let i = 1; i <= sortLevels.length; i++) {
        const num = document.createElement('span');
        num.textContent = String.fromCharCode(0x2460 + i - 1); // ①, ②, ③ ...
        num.style.cursor = 'pointer';
        num.style.fontSize = '1.2em';
        num.style.padding = '0 4px';
        if (i - 1 === idx) {
            num.style.fontWeight = 'bold';
            num.style.color = '#B0E0E6';
        }
        num.title = `Make sort order ${i}`;
        num.addEventListener('click', function(e) {
            e.stopPropagation();
            // Move col to this position
            const currentIdx = sortLevels.findIndex(s => s.column === col);
            if (currentIdx !== -1) {
                const [item] = sortLevels.splice(currentIdx, 1);
                sortLevels.splice(i - 1, 0, item);
                renderDocsTable();
                updateSortArrows();
            }
            popup.remove();
        });
        popup.appendChild(num);
    }
    // Add remove (×) button
    const removeBtn = document.createElement('span');
    removeBtn.textContent = '×';
    removeBtn.style.cursor = 'pointer';
    removeBtn.style.fontSize = '1.2em';
    removeBtn.style.color = '#dc3545';
    removeBtn.style.marginLeft = '8px';
    removeBtn.title = 'Remove from sorting';
    removeBtn.addEventListener('click', function(e) {
        e.stopPropagation();
        const currentIdx = sortLevels.findIndex(s => s.column === col);
        if (currentIdx !== -1) {
            sortLevels.splice(currentIdx, 1);
            if (sortLevels.length === 0) {
                sortLevels = [{ column: 'topics', direction: 'asc' }];
            }
            renderDocsTable();
            updateSortArrows();
        }
        popup.remove();
    });
    popup.appendChild(removeBtn);
    document.body.appendChild(popup);
    // Remove popup on outside click
    setTimeout(() => {
        document.addEventListener('mousedown', function handler(e) {
            if (!popup.contains(e.target)) {
                popup.remove();
                document.removeEventListener('mousedown', handler);
            }
        });
    }, 0);
}

// --- Patch chat send logic ---
function getSelectedChatTopicIds() {
    const menu = document.getElementById('chatTopicsDropdownMenu');
            if (!menu) return ['all'];
    const checked = menu.querySelectorAll('.form-check-input:checked');
            if (checked.length === 0) return ['all'];
    return Array.from(checked).map(cb => cb.value);
}
function getCurrentChatSessionKey() {
    const selected = getSelectedChatTopicIds();
    if (!selected || selected.length === 0 || selected.includes('all')) {
        return 'topics:all';
    }
    const sorted = [...selected].sort();
    return 'topics:' + sorted.join(',');
}
const askButton = document.getElementById('askButton');
const questionInput = document.getElementById('questionInput');
if (askButton && questionInput) {
    askButton.addEventListener('click', sendChatQuestion);
    questionInput.addEventListener('keydown', function(e) {
        if (e.key === 'Enter' && !e.shiftKey && !questionInput.disabled && !questionInput.readOnly) {
            e.preventDefault();
            sendChatQuestion();
        }
    });
}
function sendChatQuestion() {
    const input = document.getElementById('questionInput');
    const askButton = document.getElementById('askButton');
    // Prevent sending if input or button is disabled or readOnly
    if (!input || !askButton || input.disabled || input.readOnly || askButton.disabled) {
        return;
    }
    const question = input.value.trim();
    if (!question) return;
    const topic_ids = getSelectedChatTopicIds();
    const session_key = getCurrentChatSessionKey();
    // Disable input and button during processing
    input.disabled = true;
    askButton.disabled = true;
    
    addMessage('🧑 You: ' + question, 'user');
    input.value = '';
    const thinkingMessage = document.createElement('div');
    thinkingMessage.className = 'message ai-message';
    thinkingMessage.id = 'thinkingMessage';
    thinkingMessage.innerHTML = `
        <span style="font-size:2em">🤖</span> <em>Thinking...</em>
        <button id="cancelQueryBtn" class="btn btn-sm btn-outline-danger ms-3" style="font-size: 0.8em; padding: 4px 8px;">
            <i class="fas fa-times"></i> Cancel
        </button>
    `;
    document.getElementById('chatMessages').appendChild(thinkingMessage);
    document.getElementById('chatMessages').scrollTop = document.getElementById('chatMessages').scrollHeight;
    
    // Add cancel button event listener
    const cancelBtn = document.getElementById('cancelQueryBtn');
    if (cancelBtn) {
        cancelBtn.addEventListener('click', cancelCurrentQuery);
    }
    // Generate unique query ID for cancellation tracking
    window.currentQueryId = 'query_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    
    // Create abort controller for this request
    window.currentAbortController = new AbortController();
    
    // Store the current fetch request globally so it can be aborted
    window.currentFetchRequest = fetch('/ask', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ question, topic_ids, session_key, query_id: window.currentQueryId }),
        signal: window.currentAbortController.signal
    });
    
    window.currentFetchRequest
    .then(response => response.json())
    .then(data => {
        // Clear the global fetch request, abort controller, and query ID
        window.currentFetchRequest = null;
        window.currentAbortController = null;
        window.currentQueryId = null;
        
        // Re-enable input and button
        input.disabled = false;
        askButton.disabled = false;
        
        const thinkingMsg = document.getElementById('thinkingMessage');
        if (thinkingMsg) thinkingMsg.remove();
        if (data.error) {
            addMessage('❌ Error: ' + data.error, 'ai', false);
        } else {
            // Create the AI response container
            let aiResponse = '🤖 <strong>AI:</strong> ';
            
            // Always show the helpful answer first
            aiResponse += '<span class="helpful-answer">' + data.answer + '</span>';
            
            // Always show the detailed answer toggle
            // aiResponse += ' <span class="detailed-toggle" onclick="toggleDetailedAnswer(this)" data-detailed="' + (data.detailed_answer || '').replace(/"/g, '&quot;').replace(/\n/g, '<br>') + '">Detailed Answer ▼</span>';
            
            // Add confidence if available
            //if (data.confidence) {
            //    aiResponse += '<br><strong>Confidence:</strong> ' + data.confidence + '%';
            //}
            
            // Add sources if available
            if (data.sources) {
                if (typeof data.sources === 'object' && data.sources.summary && data.sources.detailed) {
                    aiResponse += '<br><strong>Sources:</strong> <span class="source-summary">' + data.sources.summary + '</span> <!-- <span class="source-toggle" onclick="toggleSourceDetails(this)" data-detailed="' + data.sources.detailed.replace(/"/g, '&quot;') + '">▼</span> -->';
                } else {
                    aiResponse += '<br><strong>Sources:</strong> ' + data.sources;
                }
            }
            
            // Add safety and hallucination information
            if (data.safety_issues && data.safety_issues.length > 0) {
                aiResponse += '<br><span class="safety-warning" style="color: #d32f2f; font-weight: bold;">⚠️ SAFETY ISSUE: ' + data.safety_issues.join(', ') + '</span>';
            }
            
            if (data.is_hallucination) {
                aiResponse += '<br><span class="safety-warning" style="color: #f57c00; font-weight: bold;">⚠️ HALLUCINATION DETECTED: This answer may contain information not directly supported by the provided documents. Please verify with official sources.</span>';
            }
            
            if (data.hallucination_score > 0.3) {
                aiResponse += '<br><span class="hallucination-score" style="color: #f57c00;">🔍 Hallucination Risk Score: ' + (data.hallucination_score * 100).toFixed(1) + '%</span>';
            }
            
            addMessage(aiResponse, 'ai', true);
            // Update chatHistories cache for this session
            if (!window.chatHistories) window.chatHistories = {};
            if (!window.chatHistories[session_key]) window.chatHistories[session_key] = [];
            window.chatHistories[session_key].push({ question, answer: data.answer });
        }
    })
    .catch(error => {
        // Check if this is an abort error (cancelled by user)
        if (error.name === 'AbortError') {
            console.log('[DEBUG] Request was aborted by user');
            return; // Don't show error message for user-initiated cancellation
        }
        
        // Clear the global fetch request, abort controller, and query ID
        window.currentFetchRequest = null;
        window.currentAbortController = null;
        window.currentQueryId = null;
        
        // Re-enable input and button
        input.disabled = false;
        askButton.disabled = false;
        
        const thinkingMsg = document.getElementById('thinkingMessage');
        if (thinkingMsg) thinkingMsg.remove();
        addMessage('❌ Error: ' + error, 'ai', false);
    });
}

// Patch Docs Management topic selection logic
window.addEventListener('DOMContentLoaded', function() {
    // ... existing code ...
    // Docs Management topic dropdown logic
    const topicDropdownMenu = document.getElementById('topicDropdownMenu');
    const topicDropdownBtn = document.getElementById('topicDropdown');
    if (topicDropdownMenu && topicDropdownBtn) {
        topicDropdownMenu.addEventListener('change', function(e) {
            const checkboxes = topicDropdownMenu.querySelectorAll('.topic-checkbox');
            const checked = Array.from(checkboxes).filter(cb => cb.checked);
            // If All Topics is checked, uncheck all others
            if (checked.some(cb => cb.value === 'all')) {
                checkboxes.forEach(cb => { cb.checked = (cb.value === 'all'); });
            } else {
                // If any other is checked, uncheck All Topics
                if (checked.length > 0) {
                    topicDropdownMenu.querySelector('.topic-checkbox[value="all"]').checked = false;
                }
                // If nothing checked, check All Topics
                const anyChecked = Array.from(checkboxes).some(cb => cb.value !== 'all' && cb.checked);
                if (!anyChecked) {
                    topicDropdownMenu.querySelector('.topic-checkbox[value="all"]').checked = true;
                }
            }
            // Trigger document reload
            loadDocuments();
        });
    }
});

// Add a button to refresh backend logs in the Logs tab
// Place this inside the logsArea div, e.g.:
// <button class="btn btn-outline-secondary mb-2" id="refreshBackendLogsBtn">Refresh Backend Logs</button>
// ... existing code ...
// Add this JS near the other event listeners:
let backendLogsInterval = null;

function fetchBackendLogs() {
    fetch('/get_backend_logs')
        .then(response => response.json())
        .then(data => {
            const logsContent = document.getElementById('logsContent');
            if (!logsContent) return;
            
            // Clear only the log messages, not the welcome message
            const messages = logsContent.querySelectorAll('.message');
            messages.forEach((message, index) => {
                if (index > 0) { // Keep the first message (welcome message)
                    message.remove();
                }
            });
            
            if (data.logs && data.logs.length > 0) {
                data.logs.forEach(line => {
                    const messageDiv = document.createElement('div');
                    messageDiv.className = 'message ai-message';
                    messageDiv.textContent = line.trim();
                    logsContent.appendChild(messageDiv);
                });
                // Removed auto-scroll to allow manual scrolling
            } else if (data.error) {
                addLogMessage('❌ Error fetching backend logs: ' + data.error);
            } else {
                // No logs yet
                const messageDiv = document.createElement('div');
                messageDiv.className = 'message ai-message';
                messageDiv.textContent = '📝 This is where system logs will show up.';
                logsContent.appendChild(messageDiv);
            }
        });
}

// Start/stop polling when Logs tab is shown/hidden
const logsTabBtn = document.getElementById('logsTabBtn');
if (logsTabBtn) {
    logsTabBtn.addEventListener('click', function() {
        fetchBackendLogs();
        if (backendLogsInterval) clearInterval(backendLogsInterval);
        backendLogsInterval = setInterval(fetchBackendLogs, 2000); // Poll every 2 seconds
    });
}

// Stop polling when switching away from Logs tab
const chatTabBtn = document.getElementById('chatTabBtn');
const docsTabBtn = document.getElementById('docsTabBtn');
function stopBackendLogsInterval() {
    if (backendLogsInterval) {
        clearInterval(backendLogsInterval);
        backendLogsInterval = null;
    }
}
if (chatTabBtn) chatTabBtn.addEventListener('click', stopBackendLogsInterval);
if (docsTabBtn) docsTabBtn.addEventListener('click', stopBackendLogsInterval);

// Clear backend logs when page is unloaded (session ends)
window.addEventListener('beforeunload', function() {
    // Clear backend logs
    fetch('/clear_backend_logs', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        }
    }).catch(error => {
        // Ignore errors when page is unloading
        console.log('Could not clear logs:', error);
    });
    
    // Clear guest session data when page is unloaded
    // This ensures guest users don't persist data between visits
    if (!window.isLoggedInUser) {  // Check if this is a guest user
        fetch('/clear_guest_session_on_exit', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            }
        }).catch(error => {
            // Ignore errors when page is unloading
            console.log('Could not clear guest session:', error);
        });
    }
});

// Clear displayed logs button functionality
const clearLogsBtn = document.getElementById('clearLogsBtn');
if (clearLogsBtn) {
    clearLogsBtn.addEventListener('click', function() {
        // Clear the backend log file first
        fetch('/clear_backend_logs', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            }
        }).then(() => {
            // Then clear the displayed logs
            const logsContent = document.getElementById('logsContent');
            if (logsContent) {
                            // Clear all messages except the welcome message
            const messages = logsContent.querySelectorAll('.message');
            messages.forEach((message, index) => {
                // Keep only the first message (welcome message), remove all others
                if (index > 0) {
                    message.remove();
                }
            });
            }
        }).catch(error => {
            console.log('Could not clear backend logs:', error);
        });
    });
}
// ... existing code ...

// Old function removed - using updateChatBarAndBatchQnAState instead

// ... existing code ...
// Chat topics dropdown logic is now handled in attachChatTopicsDropdownHandler()
// ... existing code ...
// On page load, ensure the correct state:
document.addEventListener('DOMContentLoaded', function() {
    console.log('DOM loaded, checking elements...');
    const menu = document.getElementById('chatTopicsDropdownMenu');
    console.log('Menu found on load:', menu);
    setTimeout(updateUploadQuestionnaireButton, 200); // Delay to ensure DOM is ready
    
    // Set shared user status on page load
    setSharedUserStatus();
    
    // Add integrity check button event listener
    const checkIntegrityBtn = document.getElementById('checkIntegrityBtn');
    if (checkIntegrityBtn) {
        checkIntegrityBtn.addEventListener('click', function() {
            addLogMessage('🔍 Checking database integrity...');
            
            fetch('/check_database_integrity', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                }
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    const status = data.status;
                    const message = data.message;
                    
                    if (status === 'valid') {
                        addLogMessage(`✅ Database integrity: ${message}`);
                    } else if (status === 'minor_issues' || status === 'moderate_issues') {
                        addLogMessage(`⚠️ Database integrity: ${message}`);
                    } else if (status === 'fixed') {
                        addLogMessage(`🔧 Database integrity: ${message}`);
                    } else if (status === 'rebuilt') {
                        addLogMessage(`🔄 Database integrity: ${message}`);
                    } else if (status === 'skipped') {
                        addLogMessage(`⏭️ Database integrity: ${message}`);
                    } else {
                        addLogMessage(`❓ Database integrity: ${message}`);
                    }
                } else {
                    addLogMessage(`❌ Database integrity check failed: ${data.error}`);
                }
            })
            .catch(error => {
                addLogMessage(`❌ Error checking database integrity: ${error}`);
            });
        });
    }
});
// ... existing code ...

// --- BEGIN: Separate logic for Upload Questionnaire button ---
function updateUploadQuestionnaireButton() {
    const menu = document.getElementById('chatTopicsDropdownMenu');
    const batchQnAButton = document.getElementById('batchQnAButton');
    console.log('Menu element:', menu);
    console.log('Button element:', batchQnAButton);
    if (!menu || !batchQnAButton) {
        console.log('Menu or button not found!');
        return;
    }
    
    const checked = menu.querySelectorAll('.form-check-input:checked');
    console.log('updateUploadQuestionnaireButton called, checked topics:', checked.length);
    console.log('Checked elements:', checked);
    
    // Debug: Log each checked checkbox value
    Array.from(checked).forEach((cb, index) => {
        console.log(`Checked checkbox ${index}: value="${cb.value}", id="${cb.id}"`);
    });
    
            // Check if topics are selected
        const hasValidTopics = Array.from(checked).some(cb => cb.value !== 'none');
        console.log('Has valid topics:', hasValidTopics);
        
        if (!hasValidTopics) {
            console.log('No valid topics selected, disabling button');
            batchQnAButton.disabled = true;
            batchQnAButton.classList.add('disabled-btn');
            batchQnAButton.setAttribute('title', 'Select topics with documents to enable Upload Questionnaire');
            batchQnAButton.innerHTML = '<i class="fas fa-question-circle"></i> Upload Questionnaire (No Documents)';
            return;
        }
    
    console.log('Valid topics found, proceeding with document check');
    
    // Get selected topic IDs
    const selectedTopicIds = Array.from(checked)
        .filter(cb => cb.value !== 'all')
        .map(cb => parseInt(cb.value)).filter(id => !isNaN(id));
    
    // Check if 'All Topics' is selected
    const isAllTopics = Array.from(checked).some(cb => cb.value === 'all');
    
    // Show loading state while checking
    batchQnAButton.disabled = true;
    batchQnAButton.classList.add('disabled-btn');
    batchQnAButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Checking Documents...';
    
    // For 'All Topics', check if any documents exist
    if (isAllTopics) {
        console.log('Checking All Topics for documents');
        fetch('/has_documents_for_topics', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ topic_ids: [] })
        })
        .then(response => response.json())
        .then(data => {
            console.log('API response for All Topics:', data);
            if (data.has_documents) {
                batchQnAButton.disabled = false;
                batchQnAButton.classList.remove('disabled-btn');
                batchQnAButton.setAttribute('title', '');
                batchQnAButton.innerHTML = '<i class="fas fa-question-circle"></i> Upload Questionnaire';
            } else {
                batchQnAButton.disabled = true;
                batchQnAButton.classList.add('disabled-btn');
                batchQnAButton.setAttribute('title', 'No documents found for selected topics');
                batchQnAButton.innerHTML = '<i class="fas fa-question-circle"></i> Upload Questionnaire (No Docs)';
            }
        })
        .catch(() => {
            batchQnAButton.disabled = true;
            batchQnAButton.classList.add('disabled-btn');
            batchQnAButton.setAttribute('title', 'Error checking documents');
            batchQnAButton.innerHTML = '<i class="fas fa-question-circle"></i> Upload Questionnaire (Error)';
        });
    } else {
        // For specific topics, check if documents exist for those topics
        console.log('Checking specific topics for documents:', selectedTopicIds);
        fetch('/has_documents_for_topics', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ topic_ids: selectedTopicIds })
        })
        .then(response => response.json())
        .then(data => {
            console.log('API response for specific topics:', data);
            if (data.has_documents) {
                batchQnAButton.disabled = false;
                batchQnAButton.classList.remove('disabled-btn');
                batchQnAButton.setAttribute('title', '');
                batchQnAButton.innerHTML = '<i class="fas fa-question-circle"></i> Upload Questionnaire';
            } else {
                batchQnAButton.disabled = true;
                batchQnAButton.classList.add('disabled-btn');
                batchQnAButton.setAttribute('title', 'No documents found for selected topics');
                batchQnAButton.innerHTML = '<i class="fas fa-question-circle"></i> Upload Questionnaire (No Docs)';
            }
        })
        .catch(() => {
            batchQnAButton.disabled = true;
            batchQnAButton.classList.add('disabled-btn');
            batchQnAButton.setAttribute('title', 'Error checking documents');
            batchQnAButton.innerHTML = '<i class="fas fa-question-circle"></i> Upload Questionnaire (Error)';
        });
    }
}
// --- END: Separate logic for Upload Questionnaire button ---

// Duplicate event listeners removed - using the ones above
// ... existing code ...

// Add source dropdown toggle functionality
function toggleSourceDetails(toggleElement) {
    const sourceInfo = toggleElement.closest('.source-info');
    const summary = sourceInfo.querySelector('.source-summary');
    const detailed = sourceInfo.querySelector('.source-detailed');
    
    if (detailed) {
        // Toggle existing detailed view
        detailed.remove();
        toggleElement.textContent = '▼';
    } else {
        // Show detailed view
        const detailedDiv = document.createElement('div');
        detailedDiv.className = 'source-detailed';
        detailedDiv.style.marginTop = '5px';
        detailedDiv.style.padding = '8px';
        detailedDiv.style.backgroundColor = '#f8f9fa';
        detailedDiv.style.border = '1px solid #dee2e6';
        detailedDiv.style.borderRadius = '4px';
        detailedDiv.style.fontSize = '0.9em';
        detailedDiv.style.color = '#6c757d';
        detailedDiv.style.maxWidth = '100%';
        detailedDiv.style.maxHeight = '200px';
        detailedDiv.style.overflow = 'auto';
        detailedDiv.style.whiteSpace = 'pre-wrap';
        detailedDiv.style.wordBreak = 'break-word';
        detailedDiv.textContent = toggleElement.getAttribute('data-detailed');
        
        summary.parentNode.insertBefore(detailedDiv, toggleElement);
        toggleElement.textContent = '▲';
    }
}

// Add detailed answer toggle functionality
function toggleDetailedAnswer(toggleElement) {
    // Get the message container
    const messageDiv = toggleElement.closest('.message');
    
    // Check if detailed answer already exists
    const existingDetailed = messageDiv.querySelector('.detailed-answer');
    
    if (existingDetailed) {
        // Hide detailed answer
        existingDetailed.remove();
        toggleElement.textContent = 'Detailed Answer ▼';
    } else {
        // Get the detailed content from the toggle element
        const detailedContent = toggleElement.getAttribute('data-detailed');
        
        // Only show detailed answer if there's content
        if (detailedContent && detailedContent.trim() !== '') {
            // Show detailed answer
            const detailedDiv = document.createElement('div');
            detailedDiv.className = 'detailed-answer';
            detailedDiv.style.cssText = `
                margin-top: 10px;
                padding: 12px;
                background-color: #f8f9fa;
                border: 1px solid #dee2e6;
                border-radius: 6px;
                font-size: 1em;
                color: #495057;
                max-width: 100%;
                white-space: pre-wrap;
                word-break: break-word;
                line-height: 1.5;
            `;
            
            detailedDiv.innerHTML = detailedContent;
            
            // Insert the detailed answer right after the helpful answer
            const helpfulAnswer = messageDiv.querySelector('.helpful-answer');
            if (helpfulAnswer) {
                helpfulAnswer.parentNode.insertBefore(detailedDiv, toggleElement);
            } else {
                // Fallback: insert before the toggle element
                toggleElement.parentNode.insertBefore(detailedDiv, toggleElement);
            }
            
            // Change toggle text
            toggleElement.textContent = 'Detailed Answer ▲';
        } else {
            // No detailed content available
            alert('No detailed answer available for this response.');
        }
    }
}

function monitorQuestionnaireProgress(jobId) {
    let thinkingMessage = null;
    
    const progressInterval = setInterval(() => {
        fetch(`/questionnaire_progress/${jobId}`)
        .then(response => response.json())
        .then(data => {
            if (data.error) {
                clearInterval(progressInterval);
                addLogMessage(`❌ Error tracking progress: ${data.error}`);
                if (thinkingMessage) thinkingMessage.remove();
                return;
            }
            
            // Update progress display
            if (data.status === 'processing') {
                const progress = Math.round((data.completed_questions / data.total_questions) * 100);
                updateLogMessage(`🔄 ${data.message} (${progress}% complete)`);
                
                if (data.current_question) {
                    addLogMessage(`📝 ${data.current_question}`);
                    
                    // Show thinking message in chat area with Q x/y format
                    if (thinkingMessage) {
                        thinkingMessage.remove();
                    }
                    thinkingMessage = document.createElement('div');
                    thinkingMessage.className = 'message ai-message';
                    thinkingMessage.id = 'questionnaireThinkingMessage';
                    thinkingMessage.innerHTML = `
                        <span style="font-size:2em">🤖</span> <em>Processing questionnaire...</em>
                        <div class="questionnaire-progress" style="margin-top: 10px; font-size: 0.9em; color: #666;">
                            <strong>Q ${data.completed_questions + 1}/${data.total_questions}</strong> - ${data.current_question.split(':')[1] ? data.current_question.split(':')[1].trim() : 'Processing...'}
                        </div>
                    `;
                    document.getElementById('chatMessages').appendChild(thinkingMessage);
                    document.getElementById('chatMessages').scrollTop = document.getElementById('chatMessages').scrollHeight;
                }
            } else if (data.status === 'completed') {
                clearInterval(progressInterval);
                addLogMessage(`✅ Questionnaire processing complete!`);
                addLogMessage(`📊 Processed ${data.completed_questions} questions successfully`);
                
                // Remove thinking message
                if (thinkingMessage) {
                    thinkingMessage.remove();
                }
                
                // End questionnaire mode - IDK alerts disabled for testing
                // endQuestionnaireMode();
                
                // Show download link
                showQuestionnaireResults(jobId);
            } else if (data.status === 'error') {
                clearInterval(progressInterval);
                addLogMessage(`❌ Processing failed: ${data.message}`);
                if (thinkingMessage) {
                    thinkingMessage.remove();
                }
            }
        })
        .catch(error => {
            clearInterval(progressInterval);
            addLogMessage(`❌ Error checking progress: ${error}`);
            if (thinkingMessage) {
                thinkingMessage.remove();
            }
        });
    }, 2000); // Check every 2 seconds
}

function showQuestionnaireResults(jobId) {
    console.log(`Fetching results for job: ${jobId}`);
    // Fetch the final results and show download link
    fetch(`/questionnaire_results/${jobId}`)
    .then(response => {
        console.log(`Response status: ${response.status}`);
        return response.json();
    })
    .then(data => {
        console.log('Received data:', data);
        if (data.error) {
            addLogMessage(`❌ Error getting results: ${data.error}`);
            return;
        }
        
        // Show success message with download link
        addLogMessage(`🎉 All questions processed successfully!`);
        addLogMessage(`📊 Processed ${data.questions ? data.questions.length : 0} questions`);
        
        // Create and show download link
        if (data.csv_id) {
            const downloadLink = document.createElement('div');
            downloadLink.className = 'download-section';
            downloadLink.style.cssText = `
                margin: 15px 0;
                padding: 15px;
                background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
                border-radius: 10px;
                text-align: center;
                color: white;
            `;
            
            // Build download buttons based on availability
            let downloadButtons = '';
            if (data.excel_available && data.excel_id) {
                downloadButtons += `
                    <a href="/download_excel/${data.excel_id}" 
                       class="btn btn-success btn-lg" 
                       download="${data.filename || 'questionnaire_results.xlsx'}"
                       style="text-decoration: none; font-weight: 600;">
                        <i class="fas fa-file-excel"></i> Download Excel
                    </a>`;
            }
            
            downloadButtons += `
                <a href="/download_csv/${data.csv_id}" 
                   class="btn btn-light btn-lg" 
                   download="${data.csv_filename || 'questionnaire_results.csv'}"
                   style="text-decoration: none; font-weight: 600;">
                    <i class="fas fa-download"></i> Download CSV
                </a>`;
            
            let description = '';
            if (data.excel_available) {
                description = 'Excel version highlights "No information available" responses in red<br>';
            } else {
                description = 'CSV includes Format_Flag column - use conditional formatting in your spreadsheet<br>';
            }
            description += 'Files will be automatically cleaned up after download';
            
            downloadLink.innerHTML = `
                <h5 style="margin: 0 0 10px 0; color: white;">📥 Download Results</h5>
                <p style="margin: 0 0 15px 0; font-size: 0.9em;">Your questionnaire results are ready!</p>
                <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                    ${downloadButtons}
                </div>
                <p style="margin: 10px 0 0 0; font-size: 0.8em; opacity: 0.9;">
                    ${description}
                </p>
            `;
            
            // Add the download section to the chat area
            const chatArea = document.querySelector('.chat-area');
            if (chatArea) {
                chatArea.appendChild(downloadLink);
            }
        }
        
        // Hide the panel and reset
        const batchQnAPanel = document.getElementById('batchQnAPanel');
        if (batchQnAPanel) batchQnAPanel.classList.add('hidden');
        
        // Clear the file input
        const batchQnAInput = document.getElementById('batchQnAInput');
        if (batchQnAInput) batchQnAInput.value = '';
        
        const batchQnAFileName = document.getElementById('batchQnAFileName');
        if (batchQnAFileName) batchQnAFileName.textContent = '';
        
        const batchQnAUploadBtn = document.getElementById('batchQnAUploadBtn');
        if (batchQnAUploadBtn) batchQnAUploadBtn.disabled = true;
    })
    .catch(error => {
        addLogMessage(`❌ Error fetching results: ${error}`);
    });
}

// --- BEGIN: Chat input state control based on topic selection ---
function updateChatInputState() {
    const menu = document.getElementById('chatTopicsDropdownMenu');
    const questionInput = document.getElementById('questionInput');
    const askButton = document.getElementById('askButton');
    
    console.log('=== updateChatInputState called ===');
    console.log('Menu element:', menu);
    console.log('Question input element:', questionInput);
    console.log('Ask button element:', askButton);
    
    if (!menu || !questionInput || !askButton) {
        console.log('Chat input elements not found!');
        return;
    }
    
    const checked = menu.querySelectorAll('.form-check-input:checked');
    console.log('Checked checkboxes count:', checked.length);
    
    // Log each checked checkbox
    Array.from(checked).forEach((cb, index) => {
        console.log(`Checked checkbox ${index}: value="${cb.value}", id="${cb.id}"`);
    });
    
            // Check if valid topics are selected
        const hasAllTopics = Array.from(checked).some(cb => cb.value === 'all');
        const hasSpecificTopics = Array.from(checked).some(cb => cb.value !== 'all');
        
        console.log('Has all-topics:', hasAllTopics, 'Has specific topics:', hasSpecificTopics);
        
        if (!hasAllTopics && !hasSpecificTopics) {
            // Disable chat input and send button when no valid topics are selected
            console.log('No valid topics selected, disabling chat input');
        questionInput.disabled = true;
        questionInput.readOnly = true;
        askButton.disabled = true;
        questionInput.classList.add('disabled-chat-input');
        askButton.classList.add('disabled-chat-input');
        questionInput.setAttribute('title', 'Select topics to enable chat');
        askButton.setAttribute('title', 'Select topics to enable chat');
        questionInput.placeholder = 'Select topics to enable chat...';
        
        console.log('Chat input disabled. Input disabled:', questionInput.disabled, 'Button disabled:', askButton.disabled);
    } else {
        // Enable chat input and send button when valid topics are selected
        console.log('Valid topics selected, enabling chat input');
        questionInput.disabled = false;
        questionInput.readOnly = false;
        askButton.disabled = false;
        questionInput.classList.remove('disabled-chat-input');
        askButton.classList.remove('disabled-chat-input');
        questionInput.removeAttribute('title');
        askButton.removeAttribute('title');
        questionInput.placeholder = 'Ask your compliance question...';
        
        console.log('Chat input enabled. Input disabled:', questionInput.disabled, 'Button disabled:', askButton.disabled);
    }
    
            console.log('=== updateChatInputState completed ===');
        
        // Also update the Upload Questionnaire button state
        updateUploadQuestionnaireButton();
}
// ... existing code ...

// --- BEGIN: Clear History Modal Functions ---
function showClearHistoryModal() {
    // Get all available topics dynamically
    const menu = document.getElementById('chatTopicsDropdownMenu');
    if (!menu) return;
    
    // Get individual topics (excluding 'all')
    const individualTopics = Array.from(menu.querySelectorAll('.form-check-input:not([value="all"])'));
    const allTopicsCheckbox = menu.querySelector('.form-check-input[value="all"]');
    
    // Populate individual topics dynamically
    const individualContainer = document.getElementById('individualTopicsCheckboxes');
    individualContainer.innerHTML = '';
    
    if (individualTopics.length > 0) {
        individualTopics.forEach(topic => {
            const label = menu.querySelector(`label[for="chatTopic_${topic.value}"]`);
            if (label) {
                const div = document.createElement('div');
                div.className = 'form-check';
                div.innerHTML = `
                    <input class="form-check-input clear-history-topic" type="checkbox" value="${topic.value}" id="clear_individual_${topic.value}">
                    <label class="form-check-label" for="clear_individual_${topic.value}">
                        ${label.textContent}
                    </label>
                `;
                individualContainer.appendChild(div);
            }
        });
    } else {
        individualContainer.innerHTML = '<p class="text-muted text-center">No individual topics found</p>';
    }
    
    // Populate topic combinations dynamically based on existing chat history
    const combinationContainer = document.getElementById('combinationTopicsCheckboxes');
    combinationContainer.innerHTML = '<p class="text-muted text-center"><i class="fas fa-spinner fa-spin"></i> Loading topic combinations...</p>';
    
    // Add "All Topics" option if it exists
    if (allTopicsCheckbox) {
        const div = document.createElement('div');
        div.className = 'form-check';
        div.innerHTML = `
            <input class="form-check-input clear-history-topic" type="checkbox" value="all" id="clear_combination_all">
            <label class="form-check-label" for="clear_combination_all">
                All Topics
            </label>
        `;
        combinationContainer.appendChild(div);
    }
    
    // Fetch existing topic combinations from the database
    fetchExistingTopicCombinations().then(existingCombinations => {
        // Clear the loading message
        combinationContainer.innerHTML = '';
        
        // Re-add "All Topics" option if it was cleared
        if (allTopicsCheckbox) {
            const div = document.createElement('div');
            div.className = 'form-check';
            div.innerHTML = `
                <input class="form-check-input clear-history-topic" type="checkbox" value="all" id="clear_combination_all">
                <label class="form-check-label" for="clear_combination_all">
                    All Topics
                </label>
            `;
            combinationContainer.appendChild(div);
        }
        
        if (existingCombinations && existingCombinations.length > 0) {
            existingCombinations.forEach(combo => {
                const div = document.createElement('div');
                div.className = 'form-check';
                div.innerHTML = `
                    <input class="form-check-input clear-history-topic" type="checkbox" value="${combo.session_key}" id="clear_combination_${combo.session_key.replace(/[^a-zA-Z0-9]/g, '_')}">
                    <label class="form-check-label" for="clear_combination_${combo.session_key.replace(/[^a-zA-Z0-9]/g, '_')}">
                        ${combo.display_name}
                        ${combo.message_count > 0 ? `<span class="badge bg-secondary ms-2">${combo.message_count} messages</span>` : ''}
                    </label>
                `;
                combinationContainer.appendChild(div);
            });
        } else {
            // Show "No combinations found" message
            combinationContainer.innerHTML = '<p class="text-muted text-center">No topic combinations found in chat history</p>';
        }
        
        // Re-attach event listeners for the new checkboxes
        document.querySelectorAll('.clear-history-topic').forEach(cb => {
            cb.addEventListener('change', updateClearHistoryButton);
        });
        
    }).catch(error => {
        console.error('Error fetching topic combinations:', error);
        combinationContainer.innerHTML = '<p class="text-muted text-center text-danger">Error loading topic combinations</p>';
    });
    
    // Add event listeners for select/deselect all
    document.getElementById('selectAllTopicsBtn').addEventListener('click', function() {
        document.querySelectorAll('.clear-history-topic').forEach(cb => cb.checked = true);
        updateClearHistoryButton();
    });
    
    document.getElementById('deselectAllTopicsBtn').addEventListener('click', function() {
        document.querySelectorAll('.clear-history-topic').forEach(cb => cb.checked = false);
        updateClearHistoryButton();
    });
    
    // Show the modal
    const modal = new bootstrap.Modal(document.getElementById('clearHistoryModal'));
    modal.show();
    
    // Initialize button state
    updateClearHistoryButton();
    
    // Add modal event listener to refresh content when shown
    modal._element.addEventListener('shown.bs.modal', function() {
        // Refresh content when modal is shown to ensure latest topics
        refreshModalContent();
    });
}

function updateClearHistoryButton() {
    const checkedTopics = document.querySelectorAll('.clear-history-topic:checked');
    const confirmBtn = document.getElementById('confirmClearHistoryBtn');
    
    if (checkedTopics.length > 0) {
        confirmBtn.disabled = false;
        confirmBtn.textContent = `Clear ${checkedTopics.length} Selected History`;
    } else {
        confirmBtn.disabled = true;
        confirmBtn.textContent = 'Clear Selected Histories';
    }
}

// Add event listener for confirm clear button
document.addEventListener('DOMContentLoaded', function() {
    const confirmClearBtn = document.getElementById('confirmClearHistoryBtn');
    if (confirmClearBtn) {
        confirmClearBtn.addEventListener('click', function() {
            const selectedTopics = Array.from(document.querySelectorAll('.clear-history-topic:checked')).map(cb => cb.value);
            
            if (selectedTopics.length === 0) {
                alert('Please select at least one topic to clear.');
                return;
            }
            
            // Show final confirmation
            const topicNames = selectedTopics.map(topic => {
                if (topic === 'all') return 'All Topics';
                if (topic.startsWith('clear_individual_')) return topic.replace('clear_individual_', '');
                if (topic.startsWith('clear_combination_')) return topic.replace('clear_combination_', '');
                return topic;
            }).join(', ');
            
            if (confirm(`Are you sure you want to clear chat history for: ${topicNames}?\n\nThis action cannot be undone.`)) {
                clearSelectedHistories(selectedTopics);
            }
        });
    }
});

function clearSelectedHistories(selectedTopics) {
    // Show loading state
    const confirmBtn = document.getElementById('confirmClearHistoryBtn');
    const originalText = confirmBtn.innerHTML;
    confirmBtn.disabled = true;
    confirmBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Clearing...';
    
    // Send request to clear selected histories
    fetch('/clear_history', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            topics: selectedTopics
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.status === 'success') {
            // Close modal
            const modal = bootstrap.Modal.getInstance(document.getElementById('clearHistoryModal'));
            modal.hide();
            
            // Show success message
            addLogMessage(`✅ Chat history cleared for selected topics: ${selectedTopics.join(', ')}`);
            
            // Refresh chat history for current session
            if (window.currentChatSessionKey) {
                fetchChatHistory(window.currentChatSessionKey);
            }
        } else {
            alert('Error: ' + (data.error || 'Failed to clear history'));
        }
    })
    .catch(error => {
        alert('Error clearing history: ' + error);
    })
    .finally(() => {
        // Restore button state
        confirmBtn.disabled = false;
        confirmBtn.innerHTML = originalText;
    });
}

// --- END: Clear History Modal Functions ---

// --- BEGIN: Topic Combination Fetching Functions ---
function fetchExistingTopicCombinations() {
    return fetch('/get_existing_topic_combinations')
        .then(response => {
            if (!response.ok) {
                throw new Error('Failed to fetch topic combinations');
            }
            return response.json();
        })
        .then(data => {
            if (data.status === 'success' && data.combinations) {
                return data.combinations.map(combo => {
                    // Convert session key to readable display name using actual topic names
                    let displayName = 'Unknown';
                    if (combo.session_key === 'topics:all') {
                        displayName = 'All Topics';
                    } else if (combo.session_key.startsWith('topics:')) {
                        const topicIds = combo.session_key.replace('topics:', '').split(',');
                        if (topicIds.length === 1) {
                            // Get the actual topic name from the existing topic data
                            const topicName = getTopicNameById(topicIds[0]);
                            displayName = topicName || `Topic ${topicIds[0]}`;
                        } else {
                            // Get actual topic names for combinations
                            const topicNames = topicIds.map(id => getTopicNameById(id)).filter(name => name);
                            if (topicNames.length > 0) {
                                displayName = topicNames.join(' + ');
                            } else {
                                displayName = `Topics ${topicIds.join(', ')}`;
                            }
                        }
                    }
                    
                    return {
                        session_key: combo.session_key,
                        display_name: displayName,
                        message_count: combo.message_count || 0
                    };
                }).filter(combo => combo.display_name !== 'Unknown'); // Filter out invalid combinations
            }
            return [];
        })
        .catch(error => {
            console.error('Error fetching topic combinations:', error);
            return [];
        });
}

// --- END: Topic Combination Fetching Functions ---

// --- BEGIN: Helper Functions ---
function getTopicNameById(topicId) {
    // Get topic name from the existing topic dropdown menu
    const menu = document.getElementById('chatTopicsDropdownMenu');
    if (!menu) return null;
    
    const label = menu.querySelector(`label[for="chatTopic_${topicId}"]`);
    return label ? label.textContent : null;
}

// --- END: Helper Functions ---

// --- BEGIN: Real-time Topic Update Functions ---
function refreshClearHistoryModal() {
    // If the modal is currently open, refresh its content
    const modal = document.getElementById('clearHistoryModal');
    if (modal && modal.classList.contains('show')) {
        showClearHistoryModal();
    }
}

// Function to be called when topics are updated (create/delete)
function onTopicsUpdated() {
    // Refresh the clear history modal if it's open
    refreshClearHistoryModal();
    
    // Also refresh the main topic dropdown
    if (window.refreshTopicsDropdown) {
        window.refreshTopicsDropdown();
    }
}

// Make the function globally accessible for external calls
window.onTopicsUpdated = onTopicsUpdated;
window.refreshClearHistoryModal = refreshClearHistoryModal;

// --- END: Real-time Topic Update Functions ---

// --- BEGIN: Modal Content Refresh Functions ---
function refreshModalContent() {
    // Refresh the modal content to show latest topics
    const individualContainer = document.getElementById('individualTopicsCheckboxes');
    const combinationContainer = document.getElementById('combinationTopicsCheckboxes');
    
    if (individualContainer && combinationContainer) {
        // Re-populate individual topics
        const menu = document.getElementById('chatTopicsDropdownMenu');
        if (menu) {
            const individualTopics = Array.from(menu.querySelectorAll('.form-check-input:not([value="all"])'));
            individualContainer.innerHTML = '';
            
            if (individualTopics.length > 0) {
                individualTopics.forEach(topic => {
                    const label = menu.querySelector(`label[for="chatTopic_${topic.value}"]`);
                    if (label) {
                        const div = document.createElement('div');
                        div.className = 'form-check';
                        div.innerHTML = `
                            <input class="form-check-input clear-history-topic" type="checkbox" value="${topic.value}" id="clear_individual_${topic.value}">
                            <label class="form-check-label" for="clear_individual_${topic.value}">
                                ${label.textContent}
                            </label>
                        `;
                        individualContainer.appendChild(div);
                    }
                });
            } else {
                individualContainer.innerHTML = '<p class="text-muted text-center">No individual topics found</p>';
            }
        }
        
        // Re-fetch and populate combinations
        fetchExistingTopicCombinations().then(existingCombinations => {
            combinationContainer.innerHTML = '';
            
            // Re-add "All Topics" option
            const allTopicsCheckbox = menu.querySelector('.form-check-input[value="all"]');
            if (allTopicsCheckbox) {
                const div = document.createElement('div');
                div.className = 'form-check';
                div.innerHTML = `
                    <input class="form-check-input clear-history-topic" type="checkbox" value="all" id="clear_combination_all">
                    <label class="form-check-label" for="clear_combination_all">
                        All Topics
                    </label>
                `;
                combinationContainer.appendChild(div);
            }
            
            if (existingCombinations && existingCombinations.length > 0) {
                existingCombinations.forEach(combo => {
                    const div = document.createElement('div');
                    div.className = 'form-check';
                    div.innerHTML = `
                        <input class="form-check-input clear-history-topic" type="checkbox" value="${combo.session_key}" id="clear_combination_${combo.session_key.replace(/[^a-zA-Z0-9]/g, '_')}">
                        <label class="form-check-label" for="clear_combination_${combo.session_key.replace(/[^a-zA-Z0-9]/g, '_')}">
                            ${combo.display_name}
                            ${combo.message_count > 0 ? `<span class="badge bg-secondary ms-2">${combo.message_count} messages</span>` : ''}
                        </label>
                    `;
                    combinationContainer.appendChild(div);
                });
            } else {
                combinationContainer.innerHTML = '<p class="text-muted text-center">No topic combinations found in chat history</p>';
            }
            
            // Re-attach event listeners
            document.querySelectorAll('.clear-history-topic').forEach(cb => {
                cb.addEventListener('change', updateClearHistoryButton);
            });
        });
    }
}

// --- END: Modal Content Refresh Functions ---

    </script>
</body>
</html> 